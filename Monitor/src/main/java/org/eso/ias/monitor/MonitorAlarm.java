package org.eso.ias.monitor;

import org.eso.ias.types.Alarm;
import org.eso.ias.types.Priority;

import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicReference;

/**
 * An enumerated with all the alarms generated by the Monitor tool.
 *
 * GLOBAL is a multiplicity alarm that is activated if at least one of the others
 * is SET. For that reason, {@link #set(Alarm, String)} throws exception
 * if the MonitorAlarm is GLOBAL.
 *
 * The monitor tool periodically sends these alarms.
 */
public enum MonitorAlarm {

    // Health
    PLUGIN_DEAD,
    CONVERTER_DEAD,
    SUPERVISOR_DEAD,
    SINK_DEAD,
    CLIENT_DEAD,
    CORETOOL_DEAD,
    GLOBAL; // Multiplicity

    /**
     * The ID of each alarm
     */
    public final String id;

    /**
     * The last alarm sent for this monitorAlarm
     */
    private AtomicReference<Alarm> alarm = new AtomicReference<>(Alarm.getInitialAlarmState());

    /**
     * The IDs of the faulty monitored tools (plugins, converters...)
     * to be set as property of the IASValue
     */
    private AtomicReference<String> faultyIds = new AtomicReference<>("");

    /**
     * Constructor
     */
    private MonitorAlarm() {
        this.id = "IASMON-"+this.name();
    }

    /**
     * Calculate and return the Alarm state of GLOBAL
     *
     * @return the value of the GLOBAL alarm (multiplicity)
     */
    private Alarm getGlobalAlarm() {
        if (this!=GLOBAL) {
            throw new RuntimeException("Must be called for GLOABL only");
        }

        // Get the higher priority of all the alarms that are set (if any)
        Priority topmostPriority = null;
        for (MonitorAlarm monAlarm: MonitorAlarm.values()) {
            if (monAlarm==GLOBAL || !monAlarm.alarm.get().isSet()) {
                continue;
            }
            if (topmostPriority==null || monAlarm.alarm.get().priority.compareTo(topmostPriority)>0) {
                topmostPriority=monAlarm.alarm.get().priority;
            }
        }

        if (topmostPriority!=null) { // One alarm was set so GLOBAL must be set
            GLOBAL.alarm.set(GLOBAL.alarm.get().setPriority(topmostPriority).set());
        } else {
            GLOBAL.alarm.set(GLOBAL.alarm.get().clear());
        }
        return GLOBAL.alarm.get();
    }

    /**
     * Get and return the properties of the GLOBAL alarm.
     *
     * The faulty IDs of GLOBAL is composed of all the faulty IDs of the MonitorAlarms
     * that are set
     *
     * @return the properties of the GLOBAL alarm.
     */
    private String getGlobalProperties() {
        if (this!=GLOBAL) {
            throw new UnsupportedOperationException("Must be called for GLOABL only");
        }

        StringBuilder ret = new StringBuilder();
        for (MonitorAlarm monAlarm: MonitorAlarm.values()) {
            if (monAlarm != GLOBAL && monAlarm.getAlarm().isSet() && !monAlarm.getProperties().isEmpty()) {
                if (!ret.toString().isEmpty()) {
                    ret.append(',');
                }
                ret.append(monAlarm.getProperties());
            }
        }
        return ret.toString();
    }

    /**
     * Getter
     *
     * @return The alarm
     */
    public Alarm getAlarm() {
        if (this==GLOBAL) {
            return getGlobalAlarm();
        } else {
            return alarm.get();
        }
    }

    /**
     * Getter
     *
     * @return The faulty IDs
     */
    public String getProperties() {
        if (this!=GLOBAL) {
            return faultyIds.get();
        } else {
            return getGlobalProperties();
        }
    }

    /**
     * Clear the alarm
     */
    public void clear() {
        if (this==GLOBAL) {
            throw new UnsupportedOperationException("Cannot set the state of GLoBAL");
        }
        alarm.set(alarm.get().clear());
        faultyIds.set("");
    }

    /**
     * Set an alarm
     *
     * This method can be called for each {@link MonitorAlarm} apart of GLOBAL
     * whose clearing/setting is done by {@link #getGlobalAlarm()}
     *
     * @param faultyIds the comma separated IDs of tools that did not sent the HB
     */
    public void set(String faultyIds) {
        if (this==GLOBAL) {
            throw new UnsupportedOperationException("Cannot set the state of GLOBAL");
        }
        Objects.requireNonNull(faultyIds);
        alarm.set(alarm.get().set());
        this.faultyIds.set(faultyIds);
    }

    /**
     * Set the priority of the alarm
     *
     * @param newPriority the priority to set
     */
    public void setPriority(Priority newPriority) {
        Objects.requireNonNull(newPriority);
        alarm.set(alarm.get().setPriority(newPriority));
    }
}

