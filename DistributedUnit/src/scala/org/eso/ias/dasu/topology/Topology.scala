package org.eso.ias.dasu.topology

/** The topology to forward IASIOs to ASCEs.
 * 
 * Objects of this class contains all information to move IASIOs 
 * (either coming from outside or produced by ACSEs) to ASCEs 
 * of the DASU and to the outside.
 * 
 * The topology is a composed of trees of nodes.
 * Each IASIO in input is the root of a tree i.e.
 * the topology contains as many trees as IASIOs in input.
 *  
 * Each node of a tree can be a IASIO or a ASCE. 
 * A node is connected to another if:
 * - an IASIO is the input of a ASCE
 * - the output of a ASCE is the input of another ASCE
 * 
 * The inputs to the DASU are calculated from the inputs
 * of the ASCEs running into the DASU.
 * 
 * The topology provides information to the DASO on how and when move
 * IASIOs from the input to the ASCEs and from there to the outside.
 * Such information is the level: at level 0 are all the inputs, 
 * the last level contains the output of the DASU.
 * 
 * A Topology is immutable. 
 * 
 * @constructor build a topology from the passed inputs and asces
 * @param asces the ASCES contained in the DASU
 * @param dasuOutputId the output generated by the DASU
 */
class Topology(
    asces: List[AsceTopology],
    dasuOutputId: String) {
  
  /** The output produced by all ASCEs 
   *  
   *  One of The ASCE must produce the output of the DASU
   */
  val asceOutputs: List[String] = asces.map(asce => asce.output)
  
  /** The inputs of the DASU
   * 
   * The inputs of the DASU are all the inputs of the ASCEs running
   * in the DASU that are not produced by ASCEs.
   */
  val dasuInputs: Set[String] = asces.flatMap(asce => asce.inputs).filterNot(asceOutputs.contains).toSet

  /** The trees of nodes from the inputs to the output of the DASU
   *   
   * There is one tree for each input of the DASU: each tree terminates
   * to the output of the DASU, if there are no cycles
   */
  val trees: Set[Node] = buildTrees()

  /** A linearized version of the nodes in the topology:
   *  
   *  The trees in linearizedTrees represents the same graph
   *  as in trees but where each tree has at most one neighbor.
   */
  val linearizedTrees: List[Node] = linearizeTrees(trees)
  
  /** The max deep of the trees in the topology
   *  
   *  This is the number of steps needed to update 
   *  the output of the DASU.
   */
  val maxDepth: Int = trees.map(t => getMaxDepth(t)).fold(0){ (x,y) => math.max(x,y) }
  
  /**
   * The levels used to propagate inputs inside the DASU
   * 
   * Level 0 is where the inputs are injected to the DASU.
   * The inputs are sent to the ASCEs at level 0, then
   * the same inputs plus the output produced by ASCEs at level 0 
   * are sent to ASCEs at level 1 and so on.
   * 
   */
  val levels: Array[List[String]] = Array()
  
  /** The type of the nodes of the tree  */
  object NodeType extends Enumeration {
    type NType = Value
    // ASCE is the IASIO in output generated by a ASCE
    // IASIO is a value generated outside of the DASU
    val ASCE, IASIO = Value
  }
  
  /** The immutable node of the graph.
   *  
   * The identifier of the node is the ID of the IASIO either coming from plugins, 
   * other DASUs or produced by ASCEs running in this DASU.
   * 
   * The nodes constitute the trees of the topology
   *  
   * @constructor build a node with the passed id, type and connected nodes
   * @param id the identifier of the node
   * @param nodeType the type of the node
   * @param neighbors the connected nodes
   */
  class Node(val id: String, val nodeType: NodeType.NType, val neighbors:List[Node]) {
    override def toString = id+":"+nodeType+":"+neighbors.size
  }
  
  /** Adds an ASCE to the list of ASCES 
   * 
   * @param asce the ASCE to add to the the DASU
   */
  def addAsce(asce: AsceTopology): Topology = {
    new Topology(asce::asces,dasuOutputId)
  }
  
  /** Check if the passed tree is linear
   *  i.e. if all its nodes have at most one neighbor
   *  
   *  @param node the root of the tree to check for linearity
   *  @return true if the tree is linear
   */
  def isLinearTree(node: Node): Boolean = {
    node.neighbors match {
      case Nil    => true
      case s::Nil => isLinearTree(s)
      case s::rest => false
    }
  }
  
  /** Calculate the max depth of a tree
   *  
   *  The max depth is the max number of nodes to traverse between 
   *  the passed root and a leaf.
   *  
   *  If the passed tree is linearized then there is only one
   *  possible depth but if the tree is not linearized then the 
   *  max depth is the depth of the longest tree that compose 
   *  the graph.
   * 
   * @param root the root node of the tree to calc the depth
   * @return the max depth of the tree
   */
  def getMaxDepth(root: Node): Int = {
    root.neighbors match {
      case Nil => 1
      case s::Nil => 1+getMaxDepth(s)
      case s::rest => math.max(1+getMaxDepth(s), getMaxDepth(new Node(root.id,root.nodeType,rest)))
    }
  }
  
  /** Normalizes the passed trees
   *  
   *  @param trees the trees to normalize
   *  @return A set of linearized trees where each node has at most one neighbor
   */
  def linearizeTrees(trees: Set[Node]): List[Node] = {
    trees.toList.flatMap(root => linearizeTree(root,root,Nil))
  }

  /** Clone the passed linearized tree by replace the last node with the given node.
   *  
   *  This method clones the tree whose root is rootNode till it finds lastNode.
   *  In the cloned tree lastNode is not included but replaced by the replace
   *  node.
   *  
   *  For example, having a tree like A->B-C->D and calling this method with
   *  rootNode = A
   *  lastNode=C
   *  replace=X
   *  returns A->->X
   *  
   *  @param rootNode the root of the linearized tree to clone
   *  @param lastNode the last node (exclusive) to copy in the cloned tree
   *  @param replace the node to replce lastNode in the cloned tree
   *  @return a cloned tree of rootNode where lastNode is replaced 
   *          by the replace node
   */
  def cloneReplaceTree(rootNode: Node, lastNode: Node,replace: Node): Node = {
    assert(rootNode.neighbors.size==1)
    assert(rootNode.id!=lastNode.id)
    if (rootNode.neighbors.head.id==lastNode.id) new Node(rootNode.id,rootNode.nodeType,List(replace))
    else new Node(rootNode.id,rootNode.nodeType,List(cloneReplaceTree(rootNode.neighbors.head,lastNode,replace)))
   }
  
 
  /**
   * Linearize a tree producing many trees with only one child.
   * 
   * This method transform one tree where nodes have 1-to-many neighbohrs
   * in many trees where each node has one neighbor.
   * 
   * For example a tree like this, where A has 2 neighbors B and D
   * A->B->C
   *  ->D
   * is transformed in 2 trees: A->B->C and A->D
   * 
   * @param root the root node of the tree
   * @param node the accumulator i.e. the node  currently checked 
   *             for linearity
   */
  def linearizeTree(root: Node, node: Node, trees: List[Node]): List[Node] = {
    (node.neighbors,node.nodeType) match {
      case (Nil,_)    => List(root):::trees
      case (s::Nil,_) => linearizeTree(root,s,trees)
      case (s::rest,NodeType.IASIO) => {
        // New root 
        val newRoot: Node = new Node(root.id,root.nodeType,List(s))
        val linearizedNewRoot = linearizeTree(newRoot, newRoot,trees)
        val newRootRest: Node = new Node(root.id,root.nodeType,rest)
        val linearizeRest = linearizeTree(newRootRest,newRootRest,trees)
        linearizedNewRoot:::linearizeRest:::trees
        }
      case (s::rest,NodeType.ASCE) => {
        // Root remains the same
        val newNode: Node = new Node(node.id,node.nodeType,List(s))
        val newTree = cloneReplaceTree(root,newNode,newNode)
        val linearizedNewNode = linearizeTree(newTree,newTree,trees)
        
        val newNodeRest: Node = new Node(node.id,node.nodeType,rest)
        val newRestTree = cloneReplaceTree(root,newNodeRest,newNodeRest)
        val linearizedRest = linearizeTree(newRestTree,newRestTree,trees) 
        linearizedNewNode:::linearizedRest:::trees
      }
      case (List(_,_),_) => {
        Nil
      }
    }
  }
  
  /** Build the tree of the passed Node.
   *  
   * @param node the node to build the tree
   */
  private def buildTreeOfNode(node: Node): Node = {
    assert(node.neighbors.isEmpty)
    // The IDs of the ASCEs to which this node is connected 
    val connections: List[AsceTopology] = asces.filter(a => a.isRequiredInput(node.id))
    val childs: List[Node] = connections.map(asce => buildTreeOfNode(new Node(asce.output,NodeType.ASCE,List())))
    
    val ret = new Node(
        node.id, 
        node.nodeType, 
       childs)
    
    ret
  }
  
  /** Build the trees from the IASIOs in input and the ASCEs..
   *  
   *  The root of the trees are the inputs.
   */
  private def buildTrees(): Set[Node] = {
    dasuInputs.map(inId => buildTreeOfNode(new Node(inId, NodeType.IASIO, List())))
  }
  
  /** Create a string describing a tree
   *  
   *  @param node the root of the tree
   *  @return a String describing the tree with the passed node as root
   */
  def printTree(node: Node):String = {
    val ret = new StringBuilder(node.toString())
    ret.append("isLinear=")
    ret.append(isLinearTree(node))
    val childStrs: List[String] = node.neighbors.map(n => printTree(n))
    if (!childStrs.isEmpty) {
      ret.append(" -> [")
      ret.append(childStrs.mkString(","))
      ret.append(']')
    }
    ret.toString()
  }
  
  /** Builds a human readable string describing the topology */
  override def toString = {
    val ret = new StringBuilder("Topology: output id=")
    ret.append(dasuOutputId)
    ret.append('\n')
    ret.append("Outputs of ASCES: ")
    ret.append(asceOutputs.mkString(", "))
    ret.append('\n')
    ret.append("Inputs of DASU: ")
    ret.append(dasuInputs.mkString(", "))
    ret.append(trees.foreach( node => {
      ret.append('\n')
      ret.append("Tree = ")
      ret.append(printTree(node))
    }))
    ret.toString()
  }
  
  
  
}

/** Companion providing factory methods
 */
object Topology {
  
  def main(args: Array[String]) = {
    val asce1: AsceTopology = new AsceTopology(Some("ASCE1"),Some(List[String]("IN1","IN2","IN3")),Some("OUT6"))
    val asce2: AsceTopology = new AsceTopology(Some("ASCE2"),Some(List[String]("OUT6","IN4")),Some("OUT7"))
    val asce3: AsceTopology = new AsceTopology(Some("ASCE3"),Some(List[String]("IN3","IN4","IN5")),Some("OUT8"))
    val asce4: AsceTopology = new AsceTopology(Some("ASCE4"),Some(List[String]("IN4","OUT6","OUT7","OUT8")),Some("OUT9"))
    
    val topology = Topology("OUT9")
    println("--------------------------------\nAdding asce1")
    val topology1 = topology.addAsce(asce1)
    println("--------------------------------\nAdding asce2")
    val topology2 = topology1.addAsce(asce2)
    println("--------------------------------\nAdding asce3")
    val topology3 = topology2.addAsce(asce3)
    println("--------------------------------\nAdding asce4")
    val topology4 = topology3.addAsce(asce4)
    
    
    println("\n"+topology4)
  }
  
  /** Build a topology with no inputs neither ASCEs
   *  
   *  @param dasuOutputId the output generated by the DASU
   */
  def apply(dasuOutputId: String): Topology = {
    new Topology(List[AsceTopology](),dasuOutputId)
  }
}