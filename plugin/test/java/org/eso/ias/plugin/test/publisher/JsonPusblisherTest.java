package org.eso.ias.plugin.test.publisher;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

import org.eso.ias.plugin.Sample;
import org.eso.ias.plugin.filter.FilteredValue;
import org.eso.ias.plugin.publisher.MonitorPointDataToBuffer;
import org.eso.ias.plugin.publisher.BufferedMonitoredSystemData;
import org.eso.ias.plugin.publisher.BufferedPublisherBase;
import org.eso.ias.plugin.publisher.impl.JsonFilePublisher;
import org.eso.ias.plugin.thread.PluginThreadFactory;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * Test {@link JsonFilePublisher}
 * 
 * @author acaproni
 *
 */
public class JsonPusblisherTest {
	
	/**
	 * The JSON publisher to test
	 */
	private JsonFilePublisher publisher;
	
	/**
	 * Plugin/System identifier
	 */
	private static final String SYSTEM_ID = "SystemIdent";
	
	/**
	 * The name of the server (ignored by the JSON publisher)
	 */
	private static final String SERVER_NAME = "ias.server.eso.org";
	
	/**
	 * The port of the server (ignored by the JSON publisher)
	 */
	private static final int PORT = 1967;
	
	/**
	 * The JSON file generated by the publisher
	 */
	private File jsonFile;
	
	/**
	 * The logger
	 */
	private final static Logger logger = LoggerFactory.getLogger(JsonPusblisherTest.class);

	public JsonPusblisherTest() {
		
	}
	
	@Before
	public void setUp() throws Exception {
		jsonFile = File.createTempFile("JsonPusblisherTest", ".json", new File(System.getProperty("ias.tmp.folder")));
		logger.info("JSON data will be written in: {}",jsonFile.getAbsolutePath());
		
		BufferedWriter writer = new BufferedWriter(new FileWriter(jsonFile));
		
		int poolSize = Runtime.getRuntime().availableProcessors()/2;
		ScheduledExecutorService schedExecutorSvc= Executors.newScheduledThreadPool(poolSize, PluginThreadFactory.getThreadFactory());
		publisher = new JsonFilePublisher(SYSTEM_ID, SERVER_NAME, PORT, schedExecutorSvc, writer);
		publisher.setUp();
		publisher.startSending();
	}
	
	@After
	public void tearDown() throws Exception {
		publisher.tearDown();
	}

	@Test
	public void testPublishing() throws Exception {
		List<Sample> samples = Arrays.asList(new Sample(Integer.valueOf(67)));
		
		List<FilteredValue> values = Arrays.asList(
				new FilteredValue("FV-ID1", Double.valueOf(6.7), samples, System.currentTimeMillis()),
				new FilteredValue("FV-ID2", Long.valueOf(1123), samples, System.currentTimeMillis()),
				new FilteredValue("FV-ID3", "Another string", samples, System.currentTimeMillis()),
				new FilteredValue("FV-ID4", Boolean.valueOf(false), samples, System.currentTimeMillis()),
				new FilteredValue("FV-ID5", Integer.valueOf(-98), samples, System.currentTimeMillis()));
		
		Map<String, FilteredValue> mapOfValues = new HashMap<>();

		for (FilteredValue v: values) {
			publisher.offer(Optional.of(v));
			mapOfValues.put(v.id, v);
		};
		
		// Give the publisher time to write
		Thread.sleep(5*BufferedPublisherBase.throttlingTime);
		
		// Read JSON data from file
		ObjectMapper mapper = new ObjectMapper();
		BufferedMonitoredSystemData msData = mapper.readValue(jsonFile, BufferedMonitoredSystemData.class);
		assertEquals(SYSTEM_ID,msData.getSystemID());
		assertEquals(values.size(),msData.getMonitorPoints().size());
		
		// Check the correctness of all the  MonitorPointData in the date 
		// against the submitted FilteredValue-s
		for (MonitorPointDataToBuffer mpd: msData.getMonitorPoints()) {
			FilteredValue fv = mapOfValues.get(mpd.getId());
			assertNotNull(fv);
			PublisherTestCommon.match(fv, mpd);
		}
		// Ok, everything went fine: the JSON file can be removed
		jsonFile.deleteOnExit();
	}

}
