package org.eso.ias.plugin;

import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eso.ias.plugin.filter.Filter;
import org.eso.ias.plugin.filter.Filter.ValidatedSample;
import org.eso.ias.plugin.filter.FilterException;
import org.eso.ias.plugin.filter.FilteredValue;
import org.eso.ias.plugin.filter.NoneFilter;
import org.eso.ias.prototype.input.java.IasValidity;
import org.eso.ias.prototype.input.java.OperationalMode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A MonitoredValue is a monitor point value or alarm read from the 
 * controlled system.
 * <P>
 * The history of samples needed to apply the filter is part
 * of the filter itself because its management depends on the filter.
 * <BR>For example a filter that returns only the last received value needs to save 
 * a history with only that sample, but a filter that averages the values acquired 
 * in the last minute needs a longer history even if its refresh rate is
 * much shorter then the averaging period.   
 * <P>
 * The MonitoredValue main tasks are:
 * <UL>
 * 	<LI>receive the values (samples, in (({@link #submitSample(Sample)})) of the monitor point 
 *      generated by the monitored control system and
 *      apply the filter to generate the value, a {@link ValueToSend}, to send to the IAS 
 * 	<LI>if the value has not been sent to the IAS when the refresh time interval elapses,
 *      send the value again to the core
 * </UL>
 * <P>The <code>MonitoredValue</code> sends the value the {@link #listener}, that 
 * will send it to the core of the IAS:
 * <UL>
 * 	<LI>immediately if the generated value changed
 * 	<LI>after the time interval elapses by a timer task.
 * </UL>
 * A timer task implemented by the {@link #run()} resend to the core the last value sent. 
 * 
 * @author acaproni
 *
 */
public class MonitoredValue implements Runnable {
	
	/**
	 * The logger
	 */
	private static final Logger logger = LoggerFactory.getLogger(MonitoredValue.class);
	
	/**
	 * The ID of the monitored value
	 */
	public final String id;
	
	/**
	 * The {@link #refreshRate} of the monitored can be dynamically changed
	 * but can never be less then the allowed minimum. 
	 */
	public final static long minAllowedRefreshRate=50;
	
	/**
	 * The {@link #refreshRate} of the monitored can be dynamically changed
	 * but can never be greater then the allowed maximum 
	 * to avoid the risk that the value is never sent to the core 
	 */
	public final static long maxAllowedRefreshRate=60000;
	
	/**
	 * The name of the property to set the delta time error
	 */
	public final static String validityDeltaPropName = "org.eso.ias.plugin.validity.delta";
	
	/**
	 * The delta time error in msec, to take into account chacking 
	 * if a value is valid.
	 * 
	 * @see #calcValidity()
	 */
	public static final long validityDelta = Long.getLong(validityDeltaPropName, 500);
	
	/**
	 * The actual refresh rate (msec) of this monitored value:
	 * the value must be sent to the IAS core on change or before the
	 * refresh rate expires
	 */
	public long refreshRate;
	
	/**
	 * The filter to apply to the acquired samples 
	 * before sending the value to the IAS core 
	 */
	private final Filter filter;
	
	/**
	 * The scheduled executor service.
	 * It is needed to get a signal when the refresh rate elapses.
	 */
	private final ScheduledExecutorService schedExecutorSvc;
	
	/**
	 * The listener of updates of the value of this monitored point
	 */
	private final ChangeValueListener listener;
	
	/**
	 * The last value sent to the IAS core 
	 * (i.e. to the {@link #listener}).
	 * <P>
	 * It is <code>null</code> when no value has been set.
	 */
	private ValueToSend lastSentValue = null;
	
	/**
	 * The point in time when the last value has been
	 * sent to the IAS core.
	 */
	private long lastSentTimestamp=Long.MIN_VALUE;
	
	/**
	 * The point in time when the last value has been
	 * submitted
	 */
	private long lastSubmittedTimestamp=Long.MIN_VALUE;
	
	/**
	 * The future instantiated by the timer task
	 */
	private ScheduledFuture<?> future=null;
	
	/**
	 * If <code>true</code> the <code>MonitoredValue</code> autonomously resends
	 * the last value to the core of the IAS when the refresh rate elapses.
	 * <P>
	 * It is nabled by default, and can be disabled if the generator of samples
	 * prefers to handle the periodic notification by itself by repeatedly submitting a 
	 * new sample (or the same semple).
	 */
	private final AtomicBoolean isPeriodicNotificationEnabled = new AtomicBoolean(true);
	
	/**
	 * The operational mode of this monitored value.
	 * <P>
	 * Ths mode is not sent to the core of the IAS if
	 * a plugin has a plugin operational mode set.
	 * 
	 * @see Plugin#setPluginOperationalMode(OperationalMode)
	 * @see Plugin#unsetPluginOperationalMode()
	 */
	private OperationalMode operationalMode = OperationalMode.UNKNOWN;
	
	/**
	 * The validity of this monitored value
	 */
	private IasValidity iasValidity = IasValidity.UNRELIABLE;
	
	/**
	 * Build a {@link MonitoredValue} with the passed filter
	 * @param id The identifier of the value
	 * @param refreshRate The refresh time interval in msec
	 * @param filter The filter to apply to the samples
	 * @param executorSvc The executor to schedule the thread
	 * @param listener The listener of updates
	 */
	public MonitoredValue(
			String id, 
			long refreshRate, 
			Filter filter, 
			ScheduledExecutorService executorSvc,
			ChangeValueListener listener) {
		Objects.requireNonNull(id,"The ID can't be null");
		if (id.trim().isEmpty()) {
			throw new IllegalArgumentException("Invalid empty monitored value ID string");
		}
		Objects.requireNonNull(filter,"The filter can't be null");
		Objects.requireNonNull(executorSvc,"The executor service can't be null");
		Objects.requireNonNull(listener,"The listener can't be null");
		this.id=id.trim();
		this.refreshRate=refreshRate;
		this.filter = filter;
		this.schedExecutorSvc=executorSvc;
		this.listener=listener;
		future = schedExecutorSvc.scheduleAtFixedRate(this, refreshRate, refreshRate, TimeUnit.MILLISECONDS);
		logger.debug("Monitor point {} created with a refresh rate of {}ms",this.id,this.refreshRate);
	}

	/**
	 * Build a {@link MonitoredValue} with the default filter, {@link NoneFilter}
	 * 
	 * @param id The identifier of the value
	 * @param refreshRate The refresh time interval
	 * @param executorSvc The executor to schedule the thread
	 * @param listener The listener
	 */
	public MonitoredValue(
			String id, 
			long refreshRate, 
			ScheduledExecutorService executorSvc,
			ChangeValueListener listener) {
		this(id,refreshRate, new NoneFilter(),executorSvc,listener);
	}
	
	/**
	 * Get and return the value to send i.e. the value
	 * returned applying the {@link #filter} to the #history of samples.
	 * 
	 * @return The value to send
	 */
	public Optional<FilteredValue> getValueTosend() {
		return filter.apply();
	}
	
	/**
	 * Calculate the validity of the newly submitted sample.
	 * <P>
	 * The heuristic is very simple as the validity at this stage 
	 * is only based on timing.
	 *  
	 * @return the validity
	 */
	private IasValidity calcValidity() {
		long now = System.currentTimeMillis();
		if (now-lastSubmittedTimestamp<=refreshRate+validityDelta) return IasValidity.RELIABLE;
		else return IasValidity.UNRELIABLE;
	}
	
	/**
	 * Adds a new sample to this monitor point.
	 * 
	 * @param s The not-null sample to add to the monitored value
	 * @throws FilterException If the submitted sample caused an exception in the filter
	 */
	public void submitSample(Sample s) throws FilterException {
		Objects.requireNonNull(s);
		if(future.getDelay(TimeUnit.MILLISECONDS)<=minAllowedRefreshRate) {
			rescheduleTimer();
		}
		ValidatedSample validatedSample = new ValidatedSample(s, calcValidity());
		filter.newSample(validatedSample).ifPresent(filteredValue -> notifyListener(new ValueToSend(id,filteredValue,operationalMode)));
		lastSubmittedTimestamp=System.currentTimeMillis();
	}
	
	/**
	 * Send the value to the listener that in turn will forward it to the IAS core.
	 * 
	 * @param value The not <code>null</code> value to send to the IAS
	 */
	private void notifyListener(ValueToSend value) {
		Objects.requireNonNull(value, "Cannot notify a null value");
		try {
			listener.monitoredValueUpdated(value);
			lastSentTimestamp=System.currentTimeMillis();
			lastSentValue=value;
		} catch (Exception e) {
			// In case of error sending the value, we log the exception
			// but do nothing else as we want to be ready to try to send it again
			// later
			logger.error("Error notifying the listener of the {} monitor point change", id, e);
		}
	}
	
	/**
	 * Reschedule the timer task after sending a value to the listener.
	 * <P>
	 * The timer must be scheduled to send the value to the listener 
	 * at the latest when the refresh rate elapse. 
	 */
	private synchronized void rescheduleTimer() {
		future.cancel(false);
		if (isPeriodicNotificationEnabled.get()) {
			future = schedExecutorSvc.scheduleAtFixedRate(this, refreshRate, refreshRate, TimeUnit.MILLISECONDS);
		}
	}

	/**
	 * The timer task scheduled when the refresh time interval elapses.
	 * 
	 * @see java.lang.Runnable#run()
	 */
	@Override
	public void run() {
		notifyListener(lastSentValue);
	}
	
	/**
	 * Set the new refresh rate for the monitored value with the given identifier.
	 * <P>
	 * If the periodic send is disabled, this method sets the new time interval 
	 * but does not reactivate the periodic send that must be done by 
	 * {@link #enablePeriodicNotification(boolean)}.
	 * 
	 * @param newRefreshRate The new refresh rate (msecs), must be greater then {@link #minAllowedRefreshRate}
	 *                       and less then {@link #maxAllowedRefreshRate}
	 * @return The new refresh rate (msec)
	 * 
	 */
	public synchronized long setRefreshRate(long newRefreshRate) {
		if (newRefreshRate<minAllowedRefreshRate) {
			logger.warn("The requested refresh rate {} for {} was too low: {} will be set instead",newRefreshRate,id,minAllowedRefreshRate);
			newRefreshRate=minAllowedRefreshRate;
			
		}
		if (newRefreshRate>maxAllowedRefreshRate) {
			logger.warn("The requested refresh rate {} for {} was too high: {} will be set instead",newRefreshRate,id,maxAllowedRefreshRate);
			newRefreshRate=maxAllowedRefreshRate;
		}
		refreshRate=newRefreshRate;
		rescheduleTimer();
		return newRefreshRate;
	}
	
	/**
	 * Enable or disable the periodic sending of notifications.
	 * 
	 * @param enable if <code>true</code> enables the periodic sending;
	 *                 
	 */
	public void enablePeriodicNotification(boolean enable) {
		isPeriodicNotificationEnabled.set(enable);
		rescheduleTimer();
	}
	
	/**
	 * Set the operational mode of this monitor point value.
	 * <P>
	 * Note that this value is effectively sent to the core of the IAS only if
	 * not overridden by the plugin operational mode 

	 * @param opMode The not <code>null</code> operational mode to set
	 * @return The old operational mode of the monitor point
	 */
	public OperationalMode setOperationalMode(OperationalMode opMode) {
		Objects.requireNonNull(opMode, "Invalid operational mode");
		OperationalMode ret = operationalMode;
		operationalMode= opMode;
		return ret;
	}
}
