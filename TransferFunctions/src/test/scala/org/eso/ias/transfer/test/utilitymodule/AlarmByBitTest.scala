package org.eso.ias.transfer.test.utilitymodule

import java.util.Properties
import scala.compiletime.uninitialized

import org.eso.ias.asce.exceptions.PropsMisconfiguredException
import org.eso.ias.asce.transfer.{IasIO, IasioInfo}
import org.eso.ias.logging.IASLogger
import org.eso.ias.tranfer.utlitymodule.{StatusWord, UMAlarmByBit}
import org.eso.ias.types._
import org.scalatest.{BeforeAndAfterEach}
import org.scalatest.flatspec.AnyFlatSpec

/** Test the UMAlarmByBit TF */
class AlarmByBitTest extends AnyFlatSpec with BeforeAndAfterEach {

  /** The logger */
  val logger = IASLogger.getLogger(this.getClass)

  /**  The ID of the SUPERVISOR where the components runs */
  val supervId = new Identifier("SupervId",IdentifierType.SUPERVISOR,None)

  /**  The ID of the DASU where the components runs */
  val dasuId = new Identifier("DasuId",IdentifierType.DASU,supervId)

  /** The ID of the component running into the DASU */
  val compID = new Identifier("ASCE-ID-ForTest",IdentifierType.ASCE,Option(dasuId))

  /** The ID of the output generated by the component */
  val outId = new Identifier("OutputId",IdentifierType.IASIO, Some(compID))

  /** the IASIO in output */
  val out: IasIO[Alarm] = new IasIO(InOut.asOutput(outId,IASTypes.ALARM))

  /** Output info for the initialize */
  val outputInfo = new IasioInfo(outId.id,IASTypes.ALARM)

  /** The id of input with the UM status word */
  val statusWordId = "InputId"

  /** The Identifier of the ALARM input */
  val swInputIdentifier= new Identifier(statusWordId,IdentifierType.IASIO, Some(compID))

  /** Inputs Info for the initialize */
  val swInputInOut: InOut[String] =  InOut.asInput(swInputIdentifier,IASTypes.STRING)

  /** Inputs Info for the initialize */
  val inputInfos = Set(new IasioInfo(statusWordId,IASTypes.STRING))

  /** The TF to test */
  var bitTransfer: UMAlarmByBit = uninitialized

  /** The properties to pass to the TF */
  val props: Properties = new Properties()

  /** The time frame for the validity */
  val validityTimeFrame = 2000

  override def beforeEach() : scala.Unit = {
    props.clear()
  }

  behavior of "The AlarmByBitTF"

  it must "fail if the property is not set" in {
    assertThrows[IllegalArgumentException] {
      bitTransfer = new UMAlarmByBit(compID.id, compID.fullRunningID, validityTimeFrame, props)
    }
  }

  it must "reject out of bound bits" in {
    props.put(UMAlarmByBit.BitPropertyName,"-1")
    assertThrows[PropsMisconfiguredException] {
      new UMAlarmByBit(compID.id, compID.fullRunningID, validityTimeFrame, props).initialize(inputInfos,outputInfo)
    }

    props.put(UMAlarmByBit.BitPropertyName,StatusWord.monitorPointNames.size.toString)
    assertThrows[PropsMisconfiguredException] {
      new UMAlarmByBit(compID.id, compID.fullRunningID, validityTimeFrame, props).initialize(inputInfos,outputInfo)
    }

    props.put(UMAlarmByBit.BitPropertyName,20.toString)
    assertThrows[PropsMisconfiguredException] {
      new UMAlarmByBit(compID.id, compID.fullRunningID, validityTimeFrame, props).initialize(inputInfos,outputInfo)
    }
  }

  it must "not set the alarm if the bit is not set" in {
    props.put(UMAlarmByBit.BitPropertyName,"3")
    bitTransfer = new UMAlarmByBit(compID.id, compID.fullRunningID, validityTimeFrame, props)

    for {
      bitPos <- 0 until StatusWord.monitorPointNames.size
      if (bitPos!=3)
      statusWord = new StatusWordBuilder(List(bitPos))
      input: InOut[String] = swInputInOut.updateValue(Some(statusWord.statusWordString))
      inputs = Map(statusWordId-> new IasIO(input))
      output  = bitTransfer.eval(inputs,out)
    } {
      assert(output.iasType==IASTypes.ALARM,"Unexpected output type: "+output.iasType)
      assert(output.value.isDefined)
      assert(output.value.get.isCleared)
    }
  }

  it must "set the output if the proper bit is set" in {
    props.put(UMAlarmByBit.BitPropertyName,"2")
    bitTransfer = new UMAlarmByBit(compID.id, compID.fullRunningID, validityTimeFrame, props)

    val statusWord = new StatusWordBuilder(List(1,2,5,7))
    val input: InOut[String] = swInputInOut.updateValue(Some(statusWord.statusWordString))
    val output = bitTransfer.eval(Map(statusWordId-> new IasIO(input)),out)
    assert(output.value.isDefined)
    assert(output.value.get.isSet)

    val statusWord2 = new StatusWordBuilder(List(1,3,5,6,7))
    val input2: InOut[String] = swInputInOut.updateValue(Some(statusWord2.statusWordString))
    val output2 = bitTransfer.eval(Map(statusWordId-> new IasIO(input2)),out)
    assert(output2.value.isDefined)
    assert(output2.value.get.isCleared)

  }

}
