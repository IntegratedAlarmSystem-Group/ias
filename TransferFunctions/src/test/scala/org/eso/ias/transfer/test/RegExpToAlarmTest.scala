package org.eso.ias.transfer.test

import org.eso.ias.asce.transfer.{IasIO, IasioInfo}
import org.eso.ias.logging.IASLogger
import org.eso.ias.tranfer.RegExpToAlarm
import org.eso.ias.types.*
import org.scalatest.flatspec.AnyFlatSpec

import java.util.Properties

/** A class to test [[org.eso.ias.tranfer.RegExpToAlarm]] */
class RegExpToAlarmTest extends AnyFlatSpec
{
  /** The logger */
  private val logger = IASLogger.getLogger(this.getClass)

  /**  The ID of the SUPERVISOR where the components runs */
  val supervId = new Identifier("SupervId",IdentifierType.SUPERVISOR,None)

  /**  The ID of the DASU where the components runs */
  val dasuId = new Identifier("DasuId",IdentifierType.DASU,supervId)

  /** The ID of the component running into the DASU */
  val compID = new Identifier("ASCE-ID-ForTest",IdentifierType.ASCE,Option(dasuId))

  /** The ID of the output generated by the component */
  val outId = new Identifier("OutputId",IdentifierType.IASIO, Some(compID))

  /** the IASIO in output */
  val out: IasIO[Alarm] = new IasIO(InOut.asOutput(outId,IASTypes.ALARM))

  /** Ouput info for the initialize */
  val outputInfo = new IasioInfo(outId.id,IASTypes.ALARM)

  /** THe id of th einput */
  val inputId = "Input-Id"

  /** The Identifier of the ALARM input */
  val inputIdentifier= new Identifier(inputId,IdentifierType.IASIO, Some(compID))

  /** Inputs Info for the initialize */
  val inputInOut =  InOut.asInput(inputIdentifier,IASTypes.STRING)

  /** Inputs Info for the initialize */
  val inputInfos = Set(new IasioInfo(inputId,IASTypes.STRING))

  /** The time frame for the validity */
  val validityTimeFrame = 2000

  behavior of "The RegExpToAlarmTest"

  it must "get the regular expression and logic from props or use defaults" in {
    val regExp = "ARegularExpression"
    val props = new Properties()

    // Throws exception if no regular expression has been defined
    assertThrows[IllegalArgumentException] {
      val tf = new RegExpToAlarm(compID.id, compID.fullRunningID, validityTimeFrame, props)
    }

    props.put(RegExpToAlarm.RegExpPropName,regExp)
    props.put(RegExpToAlarm.PriorityPropName,Alarm.SET_CRITICAL.toString)
    val tf2 = new RegExpToAlarm(compID.id, compID.fullRunningID, validityTimeFrame, props)
    assert(tf2.priority==Alarm.SET_CRITICAL)
    assert(tf2.regExString==regExp)
  }

  it must "produce the expected output (normal logic" in {
    val props = new Properties()
    val regExp = "a+Aleb*"
    props.put(RegExpToAlarm.RegExpPropName,regExp)

    val tf = new RegExpToAlarm(compID.id, compID.fullRunningID, validityTimeFrame, props)

    val i: InOut[_] = inputInOut.updateValue(Some("aAlebbbb"))
    val inputMap: Map[String,IasIO[_]] = Map(inputId-> new IasIO(i))
    val ret = tf.eval(inputMap,out)
    assert(ret.value.isDefined)
    assert(ret.value.get==RegExpToAlarm.DefaultPriority)

    val i2 = i.updateValue(Some("Ale"))
    val inputMap2: Map[String,IasIO[_]] = Map(inputId-> new IasIO(i2))
    val ret2 = tf.eval(inputMap2,out)
    assert(ret2.value.isDefined)
    assert(ret2.value.get==Alarm.CLEARED)

    val i3 = i2.updateValue(Some("aaaaAlebbbbb"))
    val inputMap3: Map[String,IasIO[_]] = Map(inputId-> new IasIO(i3))
    val ret3 = tf.eval(inputMap3,out)
    assert(ret3.value.isDefined)
    assert(ret3.value.get==RegExpToAlarm.DefaultPriority)
  }

  it must "produce the expected output (inverted logic)" in {
    val props = new Properties()
    val regExp = "a+Aleb*"
    props.put(RegExpToAlarm.RegExpPropName,regExp)
    props.put(RegExpToAlarm.InvertedPropName, "True")

    val tf = new RegExpToAlarm(compID.id, compID.fullRunningID, validityTimeFrame, props)

    val i: InOut[_] = inputInOut.updateValue(Some("aAlebbbb"))
    val inputMap: Map[String,IasIO[_]] = Map(inputId-> new IasIO(i))
    val ret = tf.eval(inputMap,out)
    assert(ret.value.isDefined)
    assert(ret.value.get==Alarm.CLEARED)

    val i2 = i.updateValue(Some("Ale"))
    val inputMap2: Map[String,IasIO[_]] = Map(inputId-> new IasIO(i2))
    val ret2 = tf.eval(inputMap2,out)
    assert(ret2.value.isDefined)
    assert(ret2.value.get==RegExpToAlarm.DefaultPriority)

    val i3 = i2.updateValue(Some("aaaaAlebbbbb"))
    val inputMap3: Map[String,IasIO[_]] = Map(inputId-> new IasIO(i3))
    val ret3 = tf.eval(inputMap3,out)
    assert(ret3.value.isDefined)
    assert(ret3.value.get==Alarm.CLEARED)
  }

  it must "Forward mode and properties of the input" in {
    val props = new Properties()
    val regExp = "a+Aleb*"
    props.put(RegExpToAlarm.RegExpPropName,regExp)

    val additionalProps: Map[String, String] = Map("Prop1"-> "Value1", "Prop12"-> "Value2")

    val tf = new RegExpToAlarm(compID.id, compID.fullRunningID, validityTimeFrame, props)
    val i: InOut[_] = inputInOut.updateValue(Some("aAle")).updateMode(OperationalMode.MALFUNCTIONING).updateProps(additionalProps)
    val inputMap: Map[String,IasIO[_]] = Map(inputId-> new IasIO(i))
    val ret = tf.eval(inputMap,out)
    assert(ret.value.isDefined)
    assert(ret.value.get==RegExpToAlarm.DefaultPriority)
    assert(ret.mode==OperationalMode.MALFUNCTIONING)
    assert(ret.props==additionalProps)
  }

}
