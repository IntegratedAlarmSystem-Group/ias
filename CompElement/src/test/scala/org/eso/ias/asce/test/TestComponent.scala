package org.eso.ias.asce.test

import java.util.Properties

import org.eso.ias.asce.{AsceStates, CompEleThreadFactory, ComputingElement}
import org.eso.ias.asce.transfer.{JavaTransfer, ScalaTransfer, TransferFunctionLanguage, TransferFunctionSetting}
import org.eso.ias.asce.transfer.impls.MultiplicityTF
import org.eso.ias.logging.IASLogger
import org.eso.ias.types._
import org.scalatest.FlatSpec

/**
 * Test the basic functionalities of the IAS Component,
 * while the functioning of the transfer function
 * is checked elsewhere.
 */
class TestComponent extends FlatSpec {

  /** The logger */
  private val logger = IASLogger.getLogger(this.getClass)
  
  // The ID of the DASU where the components runs
  val supervId = new Identifier("SupervId",IdentifierType.SUPERVISOR,None)
  val dasId = new Identifier("DAS-ID",IdentifierType.DASU,supervId)
  
  // The ID of the component to test
  val compId = new Identifier("ComponentId",IdentifierType.ASCE,Option[Identifier](dasId))
  
  // The ID of the output generated by the component
  val outId = new Identifier("OutputId",IdentifierType.IASIO,Option(compId))
  
  // The IDs of the monitor points in input 
  // to pass when building a Component
  val requiredInputIDs = List("ID1", "ID2")
  
  // The ID of the first MP in input
  val mpI1Identifier = new Identifier(requiredInputIDs(0),IdentifierType.IASIO,Option(compId))
  val mp1 = InOut.asInput(mpI1Identifier,IASTypes.ALARM)
  
  // The ID of the second MP in input
  val mpI2Identifier = new Identifier(requiredInputIDs(1),IdentifierType.IASIO,Option(compId))
  val mp2 = InOut.asInput(mpI2Identifier, IASTypes.ALARM)
  val actualInputs: Set[InOut[_]] = Set(mp1,mp2)
  
  // The threshold to assess the validity from the arrival time of the input
  val validityThresholdInSecs = 2
  
  behavior of "A Component"
  
  it must "catch an error instantiating a wrong TF class" in {
    logger.info("Testing with wrong TF class name")
    val output: InOut[Alarm] = InOut.asOutput(outId,IASTypes.ALARM)
    
    val threadaFactory = new CompEleThreadFactory("Test-runninId")
    // A transfer function that does not exist
    val tfSetting =new TransferFunctionSetting(
        "org.eso.ias.asce.transfer.TransferExecutorImpl",
        TransferFunctionLanguage.java,
        None,
        threadaFactory)
    val comp: ComputingElement[Alarm] = new ComputingElement[Alarm](
       compId,
       output,
       actualInputs,
       tfSetting,
       validityThresholdInSecs,
       new Properties()) with JavaTransfer[Alarm]
    
    assert(comp.asceIdentifier==compId)
    assert(comp.output.id==outId)
    
    // A newly created ASCE haa a state equal to Initializing
    assert(comp.getState()==AsceStates.Initializing)
    
    // After an error in the initialization, the state changes to TFBroken
    comp.initialize()
    assert(comp.getState()==AsceStates.TFBroken)
    comp.shutdown()
    logger.info("Testing with wrong TF class name done")
  }
  
  it must "correctly instantiate the TF" in {
    logger.info("Testing with good TF class name")
    val output: InOut[Alarm] = InOut.asOutput(outId,IASTypes.ALARM)

    val props = new Properties()
    props.put(MultiplicityTF.ThresholdPropName,"1")
    val threadaFactory = new CompEleThreadFactory("Test-runninId")

    // The transfer function
    val tfSetting =new TransferFunctionSetting(
        "org.eso.ias.asce.transfer.impls.MultiplicityTF",
        TransferFunctionLanguage.scala,
        None,
        threadaFactory)
    val comp: ComputingElement[Alarm] = new ComputingElement[Alarm](
       compId,
       output,
       actualInputs,
       tfSetting,
       validityThresholdInSecs,
      props) with ScalaTransfer[Alarm]
    
    assert(comp.asceIdentifier==compId)
    assert(comp.output.id==outId)
    
    // A newly created ASCE has a state equal to Initializing
    assert(comp.getState()==AsceStates.Initializing)
    
    // After a correct initialization, the state changes to InputsUndefined
    comp.initialize()
    assert(comp.getState()==AsceStates.InputsUndefined)
    comp.shutdown()
    logger.info("Testing with good TF class name done")
  }
  
}
