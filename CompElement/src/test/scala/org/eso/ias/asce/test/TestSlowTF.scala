package org.eso.ias.asce.test

import java.util.Properties

import org.eso.ias.asce.transfer.{ScalaTransfer, TransferFunctionLanguage, TransferFunctionSetting}
import org.eso.ias.asce.{AsceStates, ComputingElement}
import org.eso.ias.logging.IASLogger
import org.eso.ias.types._
import org.scalatest.{BeforeAndAfterEach, FlatSpec}

class TestSlowTF  extends FlatSpec with BeforeAndAfterEach {

  /** Empty properties */
  val props = new Properties()

  /** The ID of the SUPERVISOR where the components runs */
  val supervId = new Identifier("SUPERV-ID",IdentifierType.SUPERVISOR,None)

  /** The ID of the DASU where the components runs */
  val dasuId = new Identifier("DASU-ID",IdentifierType.DASU,supervId)

  /** The ID of the component running into the DASU */
  val asceId = new Identifier("ASCE-ID",IdentifierType.ASCE,Option(dasuId))

  /** The ID of the output generated by the component */
  val outId = new Identifier("Output-ID",IdentifierType.IASIO, Some(asceId))

  /** The ID of the output generated by the component */
  val inputId = new Identifier("Input-ID",IdentifierType.IASIO, Some(asceId))

  /** The output of the ASCE, not relevant for this test */
  val output: InOut[Alarm] = InOut.asOutput(outId,IASTypes.ALARM)

  val input: InOut[Boolean] =  InOut.asInput(inputId, IASTypes.BOOLEAN)

  /** The ASCE to test */
  var asce: ComputingElement[Alarm] = _

  override def beforeEach(): Unit = {
    val tfSettings = new TransferFunctionSetting(
      "org.eso.ias.asce.test.transfer.SimulatedSlowTF",
      TransferFunctionLanguage.scala,
      None,
      new TestThreadFactory())

    asce = new ComputingElement[Alarm](
      asceId,
      output,
      Set(input),
      tfSettings,
      5,
      props) with ScalaTransfer[Alarm]
    TestSlowTF.logger.info("ASCE built")

    val state = asce.initialize()
    assert(state==AsceStates.InputsUndefined)
    TestSlowTF.logger.info("ASCE initialized")
  }

  override def afterEach(): Unit = {
    asce.shutdown()
  }

  behavior of "The ASCE"

  /**
    * Check that the ASCE does not mark as slow
    * a TF that returns in time
    */
  it must "not change state for normal TFs" in {
    val iasValue = input.updateValue(Some(false)).toIASValue().updateProdTime(System.currentTimeMillis())

    for (i <- 1 to 25) {
      val ret = asce.update(Set(iasValue))
      assert(ret._2==AsceStates.Healthy)
    }

  }

  /**
    * Check that the ASCE marks the TF as slow but do not block it
    * if it does not remain slow for long time
    */
  it must "mark a TF as slow but not block before the allowed duration elapses" in {
    for (i <- 1 to 5) {
      val iasValueSlow = input.updateValue(Some(true)).toIASValue().updateProdTime(System.currentTimeMillis())
      val retSlow = asce.update(Set(iasValueSlow))
      assert(retSlow._2==AsceStates.TFSlow)

      val iasValueOk = iasValueSlow.updateValue(false).updateProdTime(System.currentTimeMillis())
      val retOk = asce.update(Set(iasValueOk))
      assert(retOk._2==AsceStates.Healthy)
    }
  }

  it must "block the execution of TF that is too slow for long time" in {
    val duration = TransferFunctionSetting.MaxAcceptableSlowDurationMillis
    val startTime = System.currentTimeMillis()
    while (System.currentTimeMillis()-startTime<duration) {
      val iasValueSlow = input.updateValue(Some(true)).toIASValue().updateProdTime(System.currentTimeMillis())
      val retSlow = asce.update(Set(iasValueSlow))
      assert(retSlow._2!=AsceStates.Healthy)
    }
    val iasValueSlow = input.updateValue(Some(true)).toIASValue().updateProdTime(System.currentTimeMillis())
    val retSlow = asce.update(Set(iasValueSlow))
    assert(retSlow._2==AsceStates.TFBroken)

    // Check that it remains broken (the TF is actually not executed)
    val iasValueOk = iasValueSlow.updateValue(false).updateProdTime(System.currentTimeMillis())
    val retOk = asce.update(Set(iasValueOk))
    assert(retOk._2==AsceStates.TFBroken)
  }


}

object TestSlowTF {
  /** The logger */
  private val logger = IASLogger.getLogger(this.getClass)
}
