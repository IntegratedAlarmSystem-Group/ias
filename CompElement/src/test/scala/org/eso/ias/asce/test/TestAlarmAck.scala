package org.eso.ias.asce.test

import org.eso.ias.asce.transfer.impls.MinMaxThresholdTF
import org.eso.ias.asce.{AsceStates, CompEleThreadFactory, ComputingElement}
import org.eso.ias.asce.transfer.{ScalaTransfer, TransferFunctionLanguage, TransferFunctionSetting}
import org.eso.ias.logging.IASLogger
import org.eso.ias.types.{Alarm, IASTypes, IASValue, Identifier, IdentifierType, InOut, Priority}
import org.scalatest.flatspec.AnyFlatSpec

import java.util.Properties

class TestAlarmAck extends AnyFlatSpec {

  /** The logger */
  private val logger = IASLogger.getLogger(this.getClass)

  // The ID of the DASU where the components runs
  val supervId = new Identifier("SupervId", IdentifierType.SUPERVISOR, None)
  val dasId = new Identifier("DASU-ID", IdentifierType.DASU, supervId)

  // The ID of the component to test
  val compId = new Identifier("AsceId", IdentifierType.ASCE, Option[Identifier](dasId))

  // The ID of the output generated by the component
  val outId = new Identifier("OutputId", IdentifierType.IASIO, Option(compId))

  // The IDs of the monitor point in input to pass when building a Component
  val requiredInputID = "ValueId"

  // The ID of the first MP in input
  val mpIIdentifier = new Identifier(requiredInputID, IdentifierType.IASIO, Option(compId))
  val inputMP = InOut.asInput(mpIIdentifier, IASTypes.LONG)

  // The input
  val initialInputs: Set[InOut[?]] = Set(inputMP)

  // Build the IASIO in output
  val output = InOut.asOutput(
    outId,
    IASTypes.ALARM)

  // The threshold to assess the validity from the arrival time of the input
  val validityThresholdInSecs = 5

  val threadFactory = new CompEleThreadFactory("Test-AckId")

  val props = new Properties()
  props.put(MinMaxThresholdTF.highOnPropName, "50")
  props.put(MinMaxThresholdTF.highOffPropName, "25")
  props.put(MinMaxThresholdTF.lowOffPropName, "-10")
  props.put(MinMaxThresholdTF.lowOnPropName, "-20")
  props.put(MinMaxThresholdTF.alarmPriorityPropName, Priority.HIGH.toString)

  def convert(iasios: Set[InOut[?]]): Set[IASValue[?]] = {
    iasios.map(io => io.toIASValue())
  }

  behavior of "The acknowledgment"

  it must "reject to ACK an alarm before it has been produced" in {
    logger.info("Testing rejection of ACK when the value of the output is still empty")

    // A transfer function that does not exist
    val tfSetting = new TransferFunctionSetting(
      "org.eso.ias.asce.transfer.impls.MinMaxThresholdTF",
      TransferFunctionLanguage.scala,
      None,
      threadFactory)

    val comp: ComputingElement[Alarm] = new ComputingElement[Alarm](
      compId,
      output.asInstanceOf[InOut[Alarm]],
      initialInputs,
      tfSetting,
      validityThresholdInSecs,
      props) with ScalaTransfer[Alarm]

    comp.initialize()

    assert(comp.getState()==AsceStates.InputsUndefined);

    assert(!comp.ack())

    comp.shutdown()
  }

  it must "ACK an alarm" in {
    logger.info("Testing rejection of ACK when the value of the output is still empty")

    // A transfer function that does not exist
    val tfSetting = new TransferFunctionSetting(
      "org.eso.ias.asce.transfer.impls.MinMaxThresholdTF",
      TransferFunctionLanguage.scala,
      None,
      threadFactory)

    val comp: ComputingElement[Alarm] = new ComputingElement[Alarm](
      compId,
      output.asInstanceOf[InOut[Alarm]],
      initialInputs,
      tfSetting,
      validityThresholdInSecs,
      props) with ScalaTransfer[Alarm]

    comp.initialize()
    assert(comp.getState() == AsceStates.InputsUndefined)

    // Trigger the alarm
    val in =  inputMP.updateValue(Some(100L)).updateProdTStamp(System.currentTimeMillis())
    val ret = comp.update(Set(in.toIASValue()))

    val out: Option[InOut[Alarm]] = ret._1
    val state = ret._2

    assert(out.get.value.isDefined)
    val outAlarm = out.get.value.get.asInstanceOf[Alarm]
    logger.info("Output produced: {}", outAlarm.toString)
    assert(outAlarm.isSet) // ALARM SET
    assert(!outAlarm.isAcked) // ALARM NOT ACKed
    // Ack the alarm
    assert(comp.ack(), "The alarm has not been ACKed?!?")

    // To check if the alarm has been acked we have to check [[ComputingElement.output]]
    // otherwise we have to run the TF again and check the output
    assert(comp.output.value.get.asInstanceOf[Alarm].isAcked, "Alarm should be ACKed but is not") // ALARM ACKed

    // Clear the alarm (remain ACKed)
    val in2 =   inputMP.updateValue(Some(0L)).updateProdTStamp(System.currentTimeMillis())
    val ret2 = comp.update(Set(in2.toIASValue()))
    val out2: Option[InOut[Alarm]] = ret2._1

    val outAlarm2 = out2.get.value.get.asInstanceOf[Alarm]
    logger.info("Output produced: {}", outAlarm2.toString)

    assert(out2.get.value.isDefined)
    assert(out2.get.value.get.asInstanceOf[Alarm].isCleared) // ALARM NOT SET
    assert(out2.get.value.get.asInstanceOf[Alarm].isAcked) // ALARM ACKed

    // Set the alarm (becomes NOT ACK)
    val in3 =   inputMP.updateValue(Some(100L)).updateProdTStamp(System.currentTimeMillis())
    val ret3 = comp.update(Set(in3.toIASValue()))
    val out3: Option[InOut[Alarm]] = ret3._1

    assert(out3.get.value.isDefined)
    val outAlarm3 = out3.get.value.get.asInstanceOf[Alarm]
    logger.info("Output produced: {}", outAlarm3.toString)
    assert(outAlarm3.isSet) // ALARM SET
    assert(!outAlarm3.isAcked) // ALARM NOT ACKed

    // Clear the alarm (remains NOT ACKed)
    val in4 = inputMP.updateValue(Some(0L)).updateProdTStamp(System.currentTimeMillis())
    val ret4 = comp.update(Set(in4.toIASValue()))
    val out4: Option[InOut[Alarm]] = ret4._1

    assert(out4.get.value.isDefined)
    val outAlarm4 = out4.get.value.get.asInstanceOf[Alarm]
    logger.info("Output produced: {}", outAlarm4.toString)
    assert(outAlarm4.isCleared) // ALARM NOT SET
    assert(!outAlarm4.isAcked) // ALARM NOT ACKed

    // ACK the alarm (becomes ACK)
    assert(comp.ack())
    assert(comp.output.value.get.asInstanceOf[Alarm].isAcked, "Alarm should be ACKed but is not") // ALARM ACKed

    // Set the alarm again (becomes NOT ACK)
    val in5 = inputMP.updateValue(Some(100L)).updateProdTStamp(System.currentTimeMillis())
    val ret5 = comp.update(Set(in5.toIASValue()))
    val out5: Option[InOut[Alarm]] = ret5._1

    assert(out5.get.value.isDefined)
    val outAlarm5 = out5.get.value.get.asInstanceOf[Alarm]
    logger.info("Output produced: {}", outAlarm3.toString)
    assert(outAlarm5.isSet) // ALARM SET
    assert(!outAlarm5.isAcked) // ALARM NOT ACKed

    // Change the input so that the alarm remains SET (and remains NOT ACK)
    val in6 = inputMP.updateValue(Some(105L)).updateProdTStamp(System.currentTimeMillis())
    val ret6 = comp.update(Set(in6.toIASValue()))
    val out6: Option[InOut[Alarm]] = ret6._1

    assert(out6.get.value.isDefined)
    val outAlarm6 = out6.get.value.get.asInstanceOf[Alarm]
    logger.info("Output produced: {}", outAlarm6.toString)
    assert(outAlarm6.isSet) // ALARM SET
    assert(!outAlarm6.isAcked) // ALARM NOT ACKed

    // ACK the alarm
    assert(comp.ack())
    assert(comp.output.value.get.asInstanceOf[Alarm].isAcked, "Alarm should be ACKed but is not") // ALARM ACKed

    // Clear the alarm (remains ACKed)
    val in7 = inputMP.updateValue(Some(0L)).updateProdTStamp(System.currentTimeMillis())
    val ret7 = comp.update(Set(in7.toIASValue()))
    val out7: Option[InOut[Alarm]] = ret7._1

    assert(out7.get.value.isDefined)
    val outAlarm7 = out7.get.value.get.asInstanceOf[Alarm]
    logger.info("Output produced: {}", outAlarm4.toString)
    assert(outAlarm7.isCleared) // ALARM NOT SET
    assert(outAlarm7.isAcked) // ALARM NOT ACKed

    comp.shutdown()
  }

}
