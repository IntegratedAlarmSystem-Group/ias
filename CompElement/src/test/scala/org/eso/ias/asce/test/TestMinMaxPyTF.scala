package org.eso.ias.asce.test

import java.util.Properties

import org.eso.ias.asce.transfer.{JavaTransfer, TransferFunctionLanguage, TransferFunctionSetting}
import org.eso.ias.asce.{CompEleThreadFactory, ComputingElement}
import org.eso.ias.logging.IASLogger
import org.eso.ias.types._
import org.scalatest.FlatSpec

import scala.collection.mutable.{Map => MutableMap}

/**
 * Test the python transfer class: build a PythonExecutorTF that, in turn,
 * delegates method execution to python code
 */
class TestMinMaxPyTF extends FlatSpec {
  /** The logger */
  private val logger = IASLogger.getLogger(this.getClass)

  /** The ID of the DASU where the components runs */
  val supervId = new Identifier("SupervId",IdentifierType.SUPERVISOR,None)
  val dasId = new Identifier("DAS-ID",IdentifierType.DASU,supervId)

  /** The ID of the component running into the DASU */
  val compID = new Identifier("COMP-ID",IdentifierType.ASCE,Option(dasId))

  // The ID of the output generated by the component
  val outId = new Identifier("OutputId",IdentifierType.IASIO,Option(compID))

  // Build the MP in output
  // The inherited validity is undefined
  val output: InOut[Alarm] = InOut.asOutput(outId, IASTypes.ALARM)

  val threadFactory: CompEleThreadFactory = new CompEleThreadFactory("Test-runningId")

  val numOfInputs = 1

  // The IDs of the monitor point in input
  // to pass when building a Component
  val inputID = "MPointID"
  val mpId = new Identifier(inputID,IdentifierType.IASIO,Option(compID))
  val mp = InOut.asInput(mpId,IASTypes.LONG).updateValue(Some(1L)).updateProdTStamp(System.currentTimeMillis())
  val inputsMPs: MutableMap[String, InOut[_]] = MutableMap[String, InOut[_]]()
  inputsMPs+=(mp.id.id -> mp)

  // The threshold to assess the validity from the arrival time of the input
  val validityThresholdInSecs = 2

  // Instantiate on ASCE with a java TF implementation
  val pythonTFSetting =new TransferFunctionSetting(
      "IasTransferFunction.Impls.MinMaxThreshold",
      TransferFunctionLanguage.python,
      None,
      threadFactory)

  val javaComp: ComputingElement[Alarm] = new ComputingElement[Alarm](
    compID,
    output,
    inputsMPs.values.toSet,
    pythonTFSetting,
    validityThresholdInSecs,
    new Properties()) with JavaTransfer[Alarm]

  behavior of "The python TransferFunctionSettings"

  it must "load and initialize the python object" in {
    logger.info("Testing initialize")
    val ret = javaComp.initialize()
    logger.info("Initialize tested")
  }

  it must "run the python TF" in {
    logger.info("Testing transfer function execution")
    val inputs = Map(inputID -> mp)
    javaComp.transfer(inputs,compID,output)
    logger.info("TF execution tested")
  }
}
