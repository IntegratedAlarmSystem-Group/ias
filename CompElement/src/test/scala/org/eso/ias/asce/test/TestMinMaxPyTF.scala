package org.eso.ias.asce.test

import java.util.Properties

import org.eso.ias.asce.transfer.{JavaTransfer, TransferFunctionLanguage, TransferFunctionSetting}
import org.eso.ias.asce.{CompEleThreadFactory, ComputingElement}
import org.eso.ias.logging.IASLogger
import org.eso.ias.types._
import org.scalatest.FlatSpec

import scala.collection.mutable.{Map => MutableMap}
import scala.util.Try

/**
 * Test the python transfer class: build a PythonExecutorTF that, in turn,
 * delegates method execution to python code
 */
class TestMinMaxPyTF extends FlatSpec {
  /** The logger */
  private val logger = IASLogger.getLogger(this.getClass)

  /** The ID of the DASU where the components runs */
  val supervId = new Identifier("SupervId",IdentifierType.SUPERVISOR,None)
  val dasId = new Identifier("DAS-ID",IdentifierType.DASU,supervId)

  /** The ID of the component running into the DASU */
  val compID = new Identifier("COMP-ID",IdentifierType.ASCE,Option(dasId))

  // The ID of the output generated by the component
  val outId = new Identifier("OutputId",IdentifierType.IASIO,Option(compID))

  // Build the MP in output
  // The inherited validity is undefined
  val output: InOut[Alarm] = InOut.asOutput(outId, IASTypes.ALARM)

  val threadFactory: CompEleThreadFactory = new CompEleThreadFactory("Test-runningId")

  val numOfInputs = 1

  // The IDs of the monitor point in input
  // to pass when building a Component
  val inputID = "MPointID"
  val mpId = new Identifier(inputID,IdentifierType.IASIO,Option(compID))
  val mp = InOut.asInput(mpId,IASTypes.LONG).updateValue(Some(1L)).updateProdTStamp(System.currentTimeMillis())
  val inputsMPs: MutableMap[String, InOut[_]] = MutableMap[String, InOut[_]]()
  inputsMPs+=(mp.id.id -> mp)

  // The threshold to assess the validity from the arrival time of the input
  val validityThresholdInSecs = 2

  // Instantiate on ASCE with a java TF implementation
  val pythonTFSetting =new TransferFunctionSetting(
      "IasTransferFunction.Impls.MinMaxThreshold",
      TransferFunctionLanguage.python,
      None,
      threadFactory)

  val props = new Properties();
  props.setProperty("HighOn","50")
  props.setProperty("HighOff","40")
  props.setProperty("LowOn","-20")
  props.setProperty("LowOff","-10")
  props.setProperty("LowOff","-10")
  props.setProperty("Priority", "SET_CRITICAL")

  val javaComp: ComputingElement[Alarm] = new ComputingElement[Alarm](
    compID,
    output,
    inputsMPs.values.toSet,
    pythonTFSetting,
    validityThresholdInSecs,
    props) with JavaTransfer[Alarm]

  behavior of "The python TransferFunctionSettings"

  it must "load and initialize the python object" in {
    logger.info("Testing initialize")
    val ret = javaComp.initialize()
    logger.info("Initialize tested")
  }

  it must "run the python TF" in {
    logger.info("Testing transfer function execution")
    val inputs = Map(inputID -> mp)
    val newOut: Try[InOut[Alarm]] = javaComp.transfer(inputs,compID,output)
    logger.info("TF execution tested")
    assert(newOut.isSuccess,"Exception got from the TF")

    val out = newOut.get
    assert (out.iasType==IASTypes.ALARM,"The TF produced a value of the worng type "+out.iasType )
    assert(out.value.isDefined)
    assert(out.value.get==Alarm.CLEARED)

    assert(out.props.isDefined)
    val props = out.props.get
    assert(props.size==1,"The TF should have set one and only one property")
    val propValue = props.get("actualValue")
    assert(propValue.isDefined,"Property actualValue NOT set")
    assert(propValue.get=="1")

    assert(out.mode==OperationalMode.UNKNOWN)
  }

  it must "set the mode of the input in the output" in {
    logger.info("Testing the setting of the Operational mode")
    val inputs = Map(inputID -> mp.updateMode(OperationalMode.OPERATIONAL))
    val newOut: Try[InOut[Alarm]] = javaComp.transfer(inputs,compID,output)
    assert(newOut.isSuccess,"Exception got from the TF")
    val out = newOut.get
    assert(out.value.isDefined)
    assert(out.mode==OperationalMode.OPERATIONAL)
  }
}
