package org.eso.ias.asce.test

import org.eso.ias.asce.transfer.impls.MultiplicityTF
import org.eso.ias.asce.transfer.{ScalaTransfer, TransferFunctionLanguage, TransferFunctionSetting}
import org.eso.ias.asce.{AsceStates, ComputingElement}
import org.eso.ias.logging.IASLogger
import org.eso.ias.types.*
import org.scalatest.BeforeAndAfterEach
import org.scalatest.flatspec.AnyFlatSpec

import java.util.Properties
import scala.jdk.javaapi.CollectionConverters

/**
 * Test the multiplicity transfer function
 */
class TestMultiplicityTF extends AnyFlatSpec with BeforeAndAfterEach {

  /** The logger */
  private val logger = IASLogger.getLogger(MultiplicityTF.getClass)
  
  val props = new Properties()
  props.put(MultiplicityTF.ThresholdPropName,"3")
  props.put(MultiplicityTF.alarmPriorityPropName,Alarm.SET_LOW.toString)
  
  val threadFactory = new TestThreadFactory()
  
  /** The ID of the SUPERVISOR where the components runs */
  val supervId = new Identifier("SUPERV-ID",IdentifierType.SUPERVISOR,None)
  
  /** The ID of the DASU where the components runs */
  val dasId = new Identifier("DASU-ID",IdentifierType.DASU,supervId)

  /** The ID of the component running into the DASU */
  val compID = new Identifier("ASCE-ID",IdentifierType.ASCE,Option(dasId))
  
  /** The ID of the output generated by the component */
  val outId = new Identifier("MultiAlarm-ID",IdentifierType.IASIO, Some(compID))
  
  /** The output of the ASCE */
  val output: InOut[Alarm] = InOut.asOutput(outId,IASTypes.ALARM)
    
  /** The Map of IASValues for updating the inputs to the ASCE */
  val inputsMPs: Set[InOut[_]]  = {
    val v = for (i <- 1 to 5) yield {
    InOut.asInput(
        new Identifier("INPUT-HIO-ID#"+i, IdentifierType.IASIO,compID),
        IASTypes.ALARM)  
    }
    v.toSet
  }
  
  // The threshold to assess the validity from the arrival time of the input
  val validityThresholdInSecs = 2
  
  /** The ASCE running the multiplicity TF with a priority set in the property */
  var scalaCompWithPriority: Option[ComputingElement[Alarm]]= None

  /** The ASCE running the multiplicity TF with no priority set in the property */
  var scalaCompWithNoPriority: Option[ComputingElement[Alarm]]= None

  override def beforeEach(): Unit = {
    val scalaMultiplicityTFWithProperty = new TransferFunctionSetting(
      "org.eso.ias.asce.transfer.impls.MultiplicityTF",
        TransferFunctionLanguage.scala,
        None,
        threadFactory)

    scalaCompWithPriority = Some(new ComputingElement[Alarm](
       compID,
       output,
       inputsMPs,
       scalaMultiplicityTFWithProperty,
       validityThresholdInSecs,
       props) with ScalaTransfer[Alarm])

    scalaCompWithPriority.get.initialize()
    Thread.sleep(1000)
    assert(scalaCompWithPriority.get.state.actualState!=AsceStates.TFBroken)

    val scalaMultiplicityTFNoProperty = new TransferFunctionSetting(
      "org.eso.ias.asce.transfer.impls.MultiplicityTF",
      TransferFunctionLanguage.scala,
      None,
      threadFactory)


    val prop2 = new Properties()
    prop2.put(MultiplicityTF.ThresholdPropName,"3")
    scalaCompWithNoPriority = Some(new ComputingElement[Alarm](
      compID,
      output,
      inputsMPs,
      scalaMultiplicityTFNoProperty,
      validityThresholdInSecs,
      prop2) with ScalaTransfer[Alarm])

    scalaCompWithNoPriority.get.initialize()
    Thread.sleep(1000)
    assert(scalaCompWithNoPriority.get.state.actualState!=AsceStates.TFBroken)

  }

  override def afterEach(): Unit =  {
    scalaCompWithPriority.get.shutdown()
    scalaCompWithNoPriority.get.shutdown()
  }

  /**
   * Check the state of the alarm of the passed IASIO
   *
   * @param asce: the ASCE to check the alarm state of the output
   * @param alarmState: The expected alarm in output
   */
  def checkAlarmActivation(asce: ComputingElement[Alarm], alarmState: Alarm): Boolean = {
    assert(asce.isOutputAnAlarm,"The output is not an alarm")
    val iasio = asce.output
    assert(iasio.iasType==IASTypes.ALARM)


    iasio.value.forall(a => {
      logger.info("Checking if {} is {}",a,alarmState)
      a==alarmState
    })
  }

  /**
   * Build and return a set of IASValue with a
   * defined number of ativated alarms
   *
   * @param n desired number of activated alarms
   */
  def activate(n: Integer): Set[IASValue[_]] = {
    require(n>0)
    val inputsMPsList = inputsMPs.toList
    val list = for (i <- inputsMPsList.indices) yield {
      if (i<=n-1) inputsMPsList(i).updateValue(Some(Alarm.SET_HIGH)).updateProdTStamp(System.currentTimeMillis()).toIASValue()
      else inputsMPsList(i).updateValue(Some(Alarm.CLEARED)).updateProdTStamp(System.currentTimeMillis()).toIASValue()
    }
    val ret: Set[IASValue[_]] = list.toSet
    assert(ret.size==inputsMPs.size)
    assert(ret.count(value => value.value==Alarm.SET_HIGH)==n)
    ret
  }

  behavior of "The scala MultiplicityTF executor with given priority"

  it must "Correctly load and shutdown the multiplicity TF executor" in {
    val multuiplicityTF = new TransferFunctionSetting(
      "org.eso.ias.asce.transfer.impls.MultiplicityTF",
        TransferFunctionLanguage.scala,
        None,
        threadFactory)

    assert(!multuiplicityTF.initialized)
    assert(!multuiplicityTF.isShutDown)
    multuiplicityTF.initialize("ASCE-MinMaxTF-ID", "ASCE-running-ID", 1000, new Properties())
    assert(!multuiplicityTF.isShutDown)
    multuiplicityTF.shutdown()
    assert(multuiplicityTF.isShutDown)
  }

  it must "run the multiplicity TF" in {
    // Change all inputs do  trigger the TF
    val changedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getSetDefault)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.SET_LOW))

    // Clearing all must disable
    val clearedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.CLEARED)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithPriority.get.update(clearedMPs)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.CLEARED))

    val act1=activate(1)
    scalaCompWithPriority.get.update(act1)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.CLEARED))

    val act2=activate(2)
    scalaCompWithPriority.get.update(act2)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.CLEARED))

    val act3=activate(3)
    scalaCompWithPriority.get.update(act3)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.SET_LOW))

    val act4=activate(4)
    scalaCompWithPriority.get.update(act4)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.SET_LOW))

    // Activate all again
    scalaCompWithPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.SET_LOW))

    // Clear all again
    scalaCompWithPriority.get.update(clearedMPs)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.CLEARED))
  }

  it must "set the IDs of active inputs in a property" in {
    // Change all inputs do  trigger the TF
    val changedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getSetDefault)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithPriority.get.update(changedMPs)
    assert(scalaCompWithPriority.get.output.value.isDefined)
    assert(scalaCompWithPriority.get.output.value.get.asInstanceOf[Alarm].isSet)

    // There must be the property with all the IDs of the alarms that are SET
    val props = scalaCompWithPriority.get.output.props
    assert(props.nonEmpty)
    assert(props.get.keys.exists(_==MultiplicityTF.inputAlarmsSetPropName))
    val valOfProp = props.get.get(MultiplicityTF.inputAlarmsSetPropName)
    assert(valOfProp.isDefined)
    val activeIDs= valOfProp.get.split(",")
    inputsMPs.map(_.id.id).forall(activeIDs.contains(_))

    // Clear the output and check that the property is not defined
    val clearedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.CLEARED)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithPriority.get.update(clearedMPs)
    assert(!scalaCompWithPriority.get.output.value.get.asInstanceOf[Alarm].isSet)
    assert(scalaCompWithPriority.get.output.props.isEmpty)

    // Activate only few alarms
    val act3=activate(3)
    scalaCompWithPriority.get.update(act3)
    assert(scalaCompWithPriority.get.output.value.get.asInstanceOf[Alarm].isSet)
    val fewPprops = scalaCompWithPriority.get.output.props
    assert(fewPprops.nonEmpty)
    assert(fewPprops.get.keys.exists(_==MultiplicityTF.inputAlarmsSetPropName))
    val valOfFewProp = fewPprops.get.get(MultiplicityTF.inputAlarmsSetPropName)
    assert(valOfFewProp.isDefined)
    val activeFewIDs= valOfFewProp.get.split(",")
    assert(activeFewIDs.size==3)
  }

  it must "propagate the properties of the SET inputs to the output" in {
    // Merge is not tested here!

    // Change all inputs do  trigger the TF
    val changedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getSetDefault)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithPriority.get.update(changedMPs)
    assert(scalaCompWithPriority.get.output.value.isDefined)
    assert(scalaCompWithPriority.get.output.value.get.asInstanceOf[Alarm].isSet)

    // The inputs have no property so the ouput only contains MultiplicityTF.inputAlarmsSetPropName
    assert(scalaCompWithPriority.get.output.props.nonEmpty)
    assert(scalaCompWithPriority.get.output.props.get.keys.size==1)
    assert(scalaCompWithPriority.get.output.props.get.keys.exists(_==MultiplicityTF.inputAlarmsSetPropName))

    // NOw CLEAR the alarm assigning properties to the inputs
    // In this case the properties of the inputs must not be propagated to the output
    val clearedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.CLEARED)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    val cleareddWithProps = clearedMPs.map(iasValue => {
      // Add a random property
      val prop = Map(iasValue.id->System.currentTimeMillis().toString)
      CollectionConverters.asJava(prop)
      iasValue.updateProperties(CollectionConverters.asJava(prop))
    })
    scalaCompWithPriority.get.update(cleareddWithProps)
    assert(!scalaCompWithPriority.get.output.value.get.asInstanceOf[Alarm].isSet)
    assert(scalaCompWithPriority.get.output.props.isEmpty)

    // Now activate only 3 alarms to set the output and check that only the properties
    // of the inputs that are set are propagated to the output
    val act3=activate(3)
    // Add props to SEt iasValues
    val act3WithProps = act3.map( iasValue => {
      val props = if (iasValue.value.asInstanceOf[Alarm].isSet) Map(iasValue.id -> "SET")
      else Map(iasValue.id -> "CLEARED")
      iasValue.updateProperties(CollectionConverters.asJava(props))
    })
    scalaCompWithPriority.get.update(act3WithProps)
    assert(scalaCompWithPriority.get.output.value.get.asInstanceOf[Alarm].isSet)
    assert(scalaCompWithPriority.get.output.props.isDefined)
    val propsOfOutput = scalaCompWithPriority.get.output.props.get
    // There must be one property for each active input (3) plus MultiplicityTF.inputAlarmsSetPropName
    assert(propsOfOutput.keys.size==4)
    // Finally check that all the property but MultiplicityTF.inputAlarmsSetPropName have a value of SET
    val validProps = propsOfOutput.keys.filter(_!=MultiplicityTF.inputAlarmsSetPropName)
    assert(validProps.forall(propsOfOutput(_)=="SET"),"Unexpected property found")
  }

  it must "merge the properties of the SET inputs to the output" in {
    val act3=activate(3)
    // Add the a prop with the same key and different value to SET iasValues
    val act3WithProps = act3.map( iasValue => {
      val props = if (iasValue.value.asInstanceOf[Alarm].isSet) Map("TestKey" -> "SET", iasValue.id->System.currentTimeMillis().toString)
      else Map("TestKey" -> "CLEARED", iasValue.id->System.currentTimeMillis().toString)
      iasValue.updateProperties(CollectionConverters.asJava(props))
    })
    scalaCompWithPriority.get.update(act3WithProps)
    assert(scalaCompWithPriority.get.output.value.get.asInstanceOf[Alarm].isSet)
    assert(scalaCompWithPriority.get.output.props.isDefined)
    val propsOfOutput = scalaCompWithPriority.get.output.props.get
    val mergedProps = propsOfOutput.get("TestKey")
    assert(mergedProps.isDefined)
    val valuesOfprop = mergedProps.get.split(",")
    assert(valuesOfprop.size==3)
    assert(valuesOfprop.forall(_=="SET"))
  }

  behavior of "The scala MultiplicityTF executor with NO given priority"

  it must "run the multiplicity TF" in {
    // The same test as before but now the TF ruturn the inputs with the highest priority

   // Change all inputs do  trigger the TF
    val changedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getSetDefault)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithNoPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.SET_MEDIUM))

    // Clearing all must disable
    val clearedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.CLEARED)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithNoPriority.get.update(clearedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.CLEARED))

    val act1=activate(1)
    scalaCompWithNoPriority.get.update(act1)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.CLEARED))

    val act2=activate(2)
    scalaCompWithNoPriority.get.update(act2)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.CLEARED))

    val act3=activate(3)
    scalaCompWithNoPriority.get.update(act3)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.SET_HIGH))

    val act4=activate(4)
    scalaCompWithNoPriority.get.update(act4)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.SET_HIGH))

    // Activate all again
    scalaCompWithNoPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.SET_MEDIUM))

    // Clear all again
    scalaCompWithNoPriority.get.update(clearedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.CLEARED))
  }
}