package org.eso.ias.asce.test

import java.util.Properties

import org.eso.ias.asce.ComputingElement
import org.eso.ias.asce.transfer.impls.MultiplicityTF
import org.eso.ias.asce.transfer.{ScalaTransfer, TransferFunctionLanguage, TransferFunctionSetting}
import org.eso.ias.types._
import org.scalatest.{BeforeAndAfterEach, FlatSpec}

/**
 * Test the multiplicity transfer function
 */
class TestMultiplicityTF extends FlatSpec with BeforeAndAfterEach {
  
  val props = new Properties()
  props.put(MultiplicityTF.ThresholdPropName,"3")
  props.put(MultiplicityTF.alarmPriorityPropName,Alarm.SET_LOW.toString())
  
  val threadFactory = new TestThreadFactory()
  
  /** The ID of the SUPERVISOR where the components runs */
  val supervId = new Identifier("SUPERV-ID",IdentifierType.SUPERVISOR,None)
  
  /** The ID of the DASU where the components runs */
  val dasId = new Identifier("DASU-ID",IdentifierType.DASU,supervId)

  /** The ID of the component running into the DASU */
  val compID = new Identifier("ASCE-ID",IdentifierType.ASCE,Option(dasId))
  
  /** The ID of the output generated by the component */
  val outId = new Identifier("MultiAlarm-ID",IdentifierType.IASIO, Some(compID))
  
  /** The output of the ASCE */
  val output: InOut[Alarm] = InOut.asOutput(outId,IASTypes.ALARM)
    
  /** The Map of IASValues for updating the inputs to the ASCE */
  val inputsMPs: Set[InOut[_]]  = {
    val v = for (i <- 1 to 5) yield {
    InOut.asInput(
        new Identifier(("INPUT-HIO-ID#"+i), IdentifierType.IASIO,compID),
        IASTypes.ALARM)  
    }
    v.toSet
  }
  
  // The threshold to assess the validity from the arrival time of the input
  val validityThresholdInSecs = 2
  
  /** The ASCE running the multiplicity TF with a priority set in the property */
  var scalaCompWithPriority: Option[ComputingElement[Alarm]]= None

  /** The ASCE running the multiplicity TF with no priority set in the property */
  var scalaCompWithNoPriority: Option[ComputingElement[Alarm]]= None

  override def beforeEach() {
    val scalaMultiplicityTFWithProperty = new TransferFunctionSetting(
      "org.eso.ias.asce.transfer.impls.MultiplicityTF",
        TransferFunctionLanguage.scala,
        None,
        threadFactory)

    scalaCompWithPriority = Some(new ComputingElement[Alarm](
       compID,
       output,
       inputsMPs,
       scalaMultiplicityTFWithProperty,
       validityThresholdInSecs,
       props) with ScalaTransfer[Alarm])

    scalaCompWithPriority.get.initialize()
    Thread.sleep(1000)

    val scalaMultiplicityTFNoProperty = new TransferFunctionSetting(
      "org.eso.ias.asce.transfer.impls.MultiplicityTF",
      TransferFunctionLanguage.scala,
      None,
      threadFactory)



    scalaCompWithNoPriority = Some(new ComputingElement[Alarm](
      compID,
      output,
      inputsMPs,
      scalaMultiplicityTFNoProperty,
      validityThresholdInSecs,
      new Properties()) with ScalaTransfer[Alarm])

    scalaCompWithNoPriority.get.initialize()
    Thread.sleep(1000)


  }

  override def afterEach() {
    scalaCompWithPriority.get.shutdown()
    scalaCompWithNoPriority.get.shutdown()
  }

  /**
   * Check the state of the alarm of the passed IASIO
   *
   * @param hio: the IASIO to check the alarm state
   * @param alarmState: The expected alarm
   */
  def checkAlarmActivation(asce: ComputingElement[Alarm], alarmState: Alarm): Boolean = {
    assert(asce.isOutputAnAlarm)
    val iasio = asce.output
    assert(iasio.iasType==IASTypes.ALARM)

    iasio.value.forall(a => a==alarmState)
  }

  /**
   * Build and return a set of IASValue with a
   * defined number of ativated alarms
   *
   * @param n desired number of activated alarms
   */
  def activate(n: Integer): Set[IASValue[_]] = {
    require(n>0)
    val inputsMPsList = inputsMPs.toList
    val list = for (i <- 0 to inputsMPsList.size-1) yield {
      if (i<=n-1) inputsMPsList(i).updateValue(Some(Alarm.SET_HIGH)).updateProdTStamp(System.currentTimeMillis()).toIASValue()
      else inputsMPsList(i).updateValue(Some(Alarm.CLEARED)).updateProdTStamp(System.currentTimeMillis()).toIASValue()
    }
    val ret = list.toSet
    assert(ret.size==inputsMPs.size)
    assert(ret.count(value => value.value==Alarm.SET_HIGH)==n)
    ret
  }

  behavior of "The scala MultiplicityTF executor with given priority"

  it must "Correctly load and shutdown the multiplicity TF executor" in {
    val multuiplicityTF = new TransferFunctionSetting(
      "org.eso.ias.asce.transfer.impls.MultiplicityTF",
        TransferFunctionLanguage.scala,
        None,
        threadFactory)

    assert(!multuiplicityTF.initialized)
    assert(!multuiplicityTF.isShutDown)
    multuiplicityTF.initialize("ASCE-MinMaxTF-ID", "ASCE-running-ID", 1000, new Properties())
    assert(!multuiplicityTF.isShutDown)
    multuiplicityTF.shutdown()
    assert(multuiplicityTF.isShutDown)
  }

  it must "run the multiplicity TF" in {
    // Change all inputs do  trigger the TF
    val changedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getSetDefault)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.SET_LOW))

    // Clearing all must disable
    val clearedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.CLEARED)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithPriority.get.update(clearedMPs)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.CLEARED))

    val act1=activate(1)
    scalaCompWithPriority.get.update(act1)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.CLEARED))

    val act2=activate(2)
    scalaCompWithPriority.get.update(act2)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.CLEARED))

    val act3=activate(3)
    scalaCompWithPriority.get.update(act3)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.SET_LOW))

    val act4=activate(4)
    scalaCompWithPriority.get.update(act4)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.SET_LOW))

    // Activate all again
    scalaCompWithPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.SET_LOW))

    // Clear all again
    scalaCompWithPriority.get.update(clearedMPs)
    assert(checkAlarmActivation(scalaCompWithPriority.get,Alarm.CLEARED))
  }

  behavior of "The scala MultiplicityTF executor with NO given priority"

  it must "run the multiplicity TF" in {
    // The same test as before but now the TF ruturn the inputs with the highest priority

   // Change all inputs do  trigger the TF
    val changedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getSetDefault)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithNoPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.SET_HIGH))

    // Clearing all must disable
    val clearedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.CLEARED)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithNoPriority.get.update(clearedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.CLEARED))

    val act1=activate(1)
    scalaCompWithNoPriority.get.update(act1)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.CLEARED))

    val act2=activate(2)
    scalaCompWithNoPriority.get.update(act2)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.CLEARED))

    val act3=activate(3)
    scalaCompWithNoPriority.get.update(act3)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.SET_HIGH))

    val act4=activate(4)
    scalaCompWithNoPriority.get.update(act4)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.SET_HIGH))

    // Activate all again
    scalaCompWithNoPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.SET_HIGH))

    // Clear all again
    scalaCompWithNoPriority.get.update(clearedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get,Alarm.CLEARED))
  }
}