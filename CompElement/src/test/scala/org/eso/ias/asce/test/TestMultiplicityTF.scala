package org.eso.ias.asce.test

import org.eso.ias.asce.transfer.impls.MultiplicityTF
import org.eso.ias.asce.transfer.{ScalaTransfer, TransferFunctionLanguage, TransferFunctionSetting}
import org.eso.ias.asce.{AsceStates, ComputingElement}
import org.eso.ias.logging.IASLogger
import org.eso.ias.types.*
import org.scalatest.BeforeAndAfterEach
import org.scalatest.flatspec.AnyFlatSpec

import java.util.Properties
import scala.jdk.javaapi.CollectionConverters

/**
 * Test the multiplicity transfer function
 */
class TestMultiplicityTF extends AnyFlatSpec with BeforeAndAfterEach {

  /** The logger */
  private val logger = IASLogger.getLogger(MultiplicityTF.getClass)
  
  val props = new Properties()
  props.put(MultiplicityTF.ThresholdPropName,"3")
  props.put(MultiplicityTF.alarmPriorityPropName, Priority.LOW.toString)
  
  val threadFactory = new TestThreadFactory()
  
  /** The ID of the SUPERVISOR where the components runs */
  val supervId = new Identifier("SUPERV-ID",IdentifierType.SUPERVISOR,None)
  
  /** The ID of the DASU where the components runs */
  val dasId = new Identifier("DASU-ID",IdentifierType.DASU,supervId)

  /** The ID of the component running into the DASU */
  val compID = new Identifier("ASCE-ID",IdentifierType.ASCE,Option(dasId))
  
  /** The ID of the output generated by the component */
  val outId = new Identifier("MultiAlarm-ID",IdentifierType.IASIO, Some(compID))
  
  /** The output of the ASCE */
  val output: InOut[Alarm] = InOut.asOutput(outId,IASTypes.ALARM)
    
  /** The Map of IASValues for updating the inputs to the ASCE */
  val inputsMPs: Set[InOut[?]]  = {
    val v = for (i <- 1 to 5) yield {
    InOut.asInput(
        new Identifier("INPUT-HIO-ID#"+i, IdentifierType.IASIO,compID),
        IASTypes.ALARM)  
    }
    v.toSet
  }
  
  // The threshold to assess the validity from the arrival time of the input
  val validityThresholdInSecs = 2
  
  /** The ASCE running the multiplicity TF with a priority set in the property */
  var scalaCompWithPriority: Option[ComputingElement[Alarm]]= None

  /** The ASCE running the multiplicity TF with no priority set in the property */
  var scalaCompWithNoPriority: Option[ComputingElement[Alarm]]= None

  override def beforeEach(): Unit = {
    val scalaMultiplicityTFWithProperty = new TransferFunctionSetting(
      "org.eso.ias.asce.transfer.impls.MultiplicityTF",
        TransferFunctionLanguage.scala,
        None,
        threadFactory)

    scalaCompWithPriority = Some(new ComputingElement[Alarm](
       compID,
       output,
       inputsMPs,
       scalaMultiplicityTFWithProperty,
       validityThresholdInSecs,
       props) with ScalaTransfer[Alarm])

    scalaCompWithPriority.get.initialize()
    Thread.sleep(1000)
    assert(scalaCompWithPriority.get.state.actualState!=AsceStates.TFBroken)

    val scalaMultiplicityTFNoProperty = new TransferFunctionSetting(
      "org.eso.ias.asce.transfer.impls.MultiplicityTF",
      TransferFunctionLanguage.scala,
      None,
      threadFactory)


    val prop2 = new Properties()
    prop2.put(MultiplicityTF.ThresholdPropName,"3")
    scalaCompWithNoPriority = Some(new ComputingElement[Alarm](
      compID,
      output,
      inputsMPs,
      scalaMultiplicityTFNoProperty,
      validityThresholdInSecs,
      prop2) with ScalaTransfer[Alarm])

    scalaCompWithNoPriority.get.initialize()
    Thread.sleep(1000)
    assert(scalaCompWithNoPriority.get.state.actualState!=AsceStates.TFBroken)

  }

  override def afterEach(): Unit =  {
    scalaCompWithPriority.get.shutdown()
    scalaCompWithNoPriority.get.shutdown()
  }

  /**
   * Check the state of the alarm of the passed IASIO
   *
   * @param asce: the ASCE to check the alarm state of the output
   * @param alarmState: The expected alarm in output
   * @return True if the alarm is SET, False otherwise
   */
  def checkAlarmActivation(asce: ComputingElement[Alarm], isSet: Boolean): Boolean = {
    assert(asce.isOutputAnAlarm,"The output is not an alarm")
    val iasio = asce.output
    assert(iasio.iasType==IASTypes.ALARM)

    iasio.value.forall(a => {
      logger.info("Checking if {} activation state is {}",a,isSet)
      a.asInstanceOf[Alarm].isSet==isSet
    })
  }

  /**
   * Build and return a set of IASValue with a
   * defined number of ativated alarms
   *
   * @param n desired number of activated alarms
   */
  def activate(n: Integer): Set[IASValue[?]] = {
    require(n>0)
    val inputsMPsList = inputsMPs.toList
    val list = for (i <- inputsMPsList.indices) yield {
      if (i<=n-1) inputsMPsList(i).updateValue(Some(Alarm.getInitialAlarmState(Priority.HIGH).set())).updateProdTStamp(System.currentTimeMillis()).toIASValue()
      else inputsMPsList(i).updateValue(Some(Alarm.getInitialAlarmState())).updateProdTStamp(System.currentTimeMillis()).toIASValue()
    }
    val ret: Set[IASValue[?]] = list.toSet
    assert(ret.size==inputsMPs.size)
    assert(ret.count(value => value.value.asInstanceOf[Alarm].isSet)==n)
    ret
  }

  /**
    * Check if in the set, the value with the passed id has the passed validity
    *
    * @param values The set of values from where to get the IASValue with the given ID
    * @param id the ID of the IASValue to check
    * @param validity the requested validity
    * @return True iif the IASValue with the given id has a validity equal to validity
    */
  def checkValidity(values: Set[IASValue[?]], id: String, validity: IasValidity): Boolean = {
    val set: Set[IASValue[?]]=values.filter(_.id==id)
    assert(set.size==1)
    set.forall(_.iasValidity==validity)
  }

  /**
    * Set the validity of the passed value.
    * Being IASValue immutable, a new object is built if the validity
    * to set differs from the validity of the passed IASValue 
    *
    * @param iasValue the value whose validity must be changed
    * @param validity the validity to set
    * @return a IASValue with the validity set 
    */
  def setValidity(iasValue: IASValue[?], validity: IasValidity): IASValue[?] = {
    if (iasValue.iasValidity==validity) return iasValue
    val value = iasValue.asInstanceOf[IASValue[Alarm]]
    return new IASValue[Alarm](
				value.value,
				value.mode,
				validity,
				value.fullRunningId,
				value.valueType,
				value.readFromMonSysTStamp,
				value.productionTStamp,
				value.sentToConverterTStamp,
				value.receivedFromPluginTStamp,
				value.convertedProductionTStamp,
				value.sentToBsdbTStamp,
				value.readFromBsdbTStamp,
				value.dependentsFullRuningIds,
				value.props);
  }

  behavior of "The scala MultiplicityTF executor with given priority"

  it must "Correctly load and shutdown the multiplicity TF executor" in {
    val multuiplicityTF = new TransferFunctionSetting(
      "org.eso.ias.asce.transfer.impls.MultiplicityTF",
        TransferFunctionLanguage.scala,
        None,
        threadFactory)

    assert(!multuiplicityTF.initialized)
    assert(!multuiplicityTF.isShutDown)
    multuiplicityTF.initialize("ASCE-MinMaxTF-ID", "ASCE-running-ID", 1000, new Properties())
    assert(!multuiplicityTF.isShutDown)
    multuiplicityTF.shutdown()
    assert(multuiplicityTF.isShutDown)
  }

  it must "run the multiplicity TF" in {
    // Change all inputs do  trigger the TF
    val changedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getInitialAlarmState.set())).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithPriority.get, true))

    // Clearing all must disable
    val clearedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getInitialAlarmState)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithPriority.get.update(clearedMPs)
    assert(checkAlarmActivation(scalaCompWithPriority.get, false))

    val act1=activate(1)
    scalaCompWithPriority.get.update(act1)
    assert(checkAlarmActivation(scalaCompWithPriority.get, false))

    val act2=activate(2)
    scalaCompWithPriority.get.update(act2)
    assert(checkAlarmActivation(scalaCompWithPriority.get, false))

    val act3=activate(3)
    scalaCompWithPriority.get.update(act3)
    assert(checkAlarmActivation(scalaCompWithPriority.get, true))

    val act4=activate(4)
    scalaCompWithPriority.get.update(act4)
    assert(checkAlarmActivation(scalaCompWithPriority.get, true))

    // Activate all again
    scalaCompWithPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithPriority.get, true))

    // Clear all again
    scalaCompWithPriority.get.update(clearedMPs)
    assert(checkAlarmActivation(scalaCompWithPriority.get, false))
  }

  it must "set the IDs of active inputs in a property" in {
    // Change all inputs do  trigger the TF
    val changedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getInitialAlarmState.set())).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithPriority.get.update(changedMPs)
    assert(scalaCompWithPriority.get.output.value.isDefined)
    assert(scalaCompWithPriority.get.output.value.get.asInstanceOf[Alarm].isSet)

    // There must be the property with all the IDs of the alarms that are SET
    val props = scalaCompWithPriority.get.output.props
    assert(props.nonEmpty)
    assert(props.get.keys.exists(_==MultiplicityTF.inputAlarmsSetPropName))
    val valOfProp = props.get.get(MultiplicityTF.inputAlarmsSetPropName)
    assert(valOfProp.isDefined)
    val activeIDs= valOfProp.get.split(",")
    inputsMPs.map(_.id.id).forall(activeIDs.contains(_))

    // Clear the output and check that the property is not defined
    val clearedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getInitialAlarmState)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithPriority.get.update(clearedMPs)
    assert(!scalaCompWithPriority.get.output.value.get.asInstanceOf[Alarm].isSet)
    assert(scalaCompWithPriority.get.output.props.isEmpty)

    // Activate only few alarms
    val act3=activate(3)
    scalaCompWithPriority.get.update(act3)
    assert(scalaCompWithPriority.get.output.value.get.asInstanceOf[Alarm].isSet)
    val fewPprops = scalaCompWithPriority.get.output.props
    assert(fewPprops.nonEmpty)
    assert(fewPprops.get.keys.exists(_==MultiplicityTF.inputAlarmsSetPropName))
    val valOfFewProp = fewPprops.get.get(MultiplicityTF.inputAlarmsSetPropName)
    assert(valOfFewProp.isDefined)
    val activeFewIDs= valOfFewProp.get.split(",")
    assert(activeFewIDs.size==3)
  }

  it must "propagate the properties of the SET inputs to the output" in {
    // Merge is not tested here!

    // Change all inputs do  trigger the TF
    val changedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getInitialAlarmState.set())).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithPriority.get.update(changedMPs)
    assert(scalaCompWithPriority.get.output.value.isDefined)
    assert(scalaCompWithPriority.get.output.value.get.asInstanceOf[Alarm].isSet)

    // The inputs have no property so the ouput only contains MultiplicityTF.inputAlarmsSetPropName
    assert(scalaCompWithPriority.get.output.props.nonEmpty)
    assert(scalaCompWithPriority.get.output.props.get.keys.size==1)
    assert(scalaCompWithPriority.get.output.props.get.keys.exists(_==MultiplicityTF.inputAlarmsSetPropName))

    // NOw CLEAR the alarm assigning properties to the inputs
    // In this case the properties of the inputs must not be propagated to the output
    val clearedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getInitialAlarmState)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    val cleareddWithProps = clearedMPs.map(iasValue => {
      // Add a random property
      val prop = Map(iasValue.id->System.currentTimeMillis().toString)
      CollectionConverters.asJava(prop)
      iasValue.updateProperties(CollectionConverters.asJava(prop))
    })
    scalaCompWithPriority.get.update(cleareddWithProps)
    assert(!scalaCompWithPriority.get.output.value.get.asInstanceOf[Alarm].isSet)
    assert(scalaCompWithPriority.get.output.props.isEmpty)

    // Now activate only 3 alarms to set the output and check that only the properties
    // of the inputs that are set are propagated to the output
    val act3=activate(3)
    // Add props to SEt iasValues
    val act3WithProps = act3.map( iasValue => {
      val props = if (iasValue.value.asInstanceOf[Alarm].isSet) Map(iasValue.id -> "SET")
      else Map(iasValue.id -> "CLEARED")
      iasValue.updateProperties(CollectionConverters.asJava(props))
    })
    scalaCompWithPriority.get.update(act3WithProps)
    assert(scalaCompWithPriority.get.output.value.get.asInstanceOf[Alarm].isSet)
    assert(scalaCompWithPriority.get.output.props.isDefined)
    val propsOfOutput = scalaCompWithPriority.get.output.props.get
    // There must be one property for each active input (3) plus MultiplicityTF.inputAlarmsSetPropName
    assert(propsOfOutput.keys.size==4)
    // Finally check that all the property but MultiplicityTF.inputAlarmsSetPropName have a value of SET
    val validProps = propsOfOutput.keys.filter(_!=MultiplicityTF.inputAlarmsSetPropName)
    assert(validProps.forall(propsOfOutput(_)=="SET"),"Unexpected property found")
  }

  it must "merge the properties of the SET inputs to the output" in {
    val act3=activate(3)
    // Add the a prop with the same key and different value to SET iasValues
    val act3WithProps = act3.map( iasValue => {
      val props = if (iasValue.value.asInstanceOf[Alarm].isSet) Map("TestKey" -> "SET", iasValue.id->System.currentTimeMillis().toString)
      else Map("TestKey" -> "CLEARED", iasValue.id->System.currentTimeMillis().toString)
      iasValue.updateProperties(CollectionConverters.asJava(props))
    })
    scalaCompWithPriority.get.update(act3WithProps)
    assert(scalaCompWithPriority.get.output.value.get.asInstanceOf[Alarm].isSet)
    assert(scalaCompWithPriority.get.output.props.isDefined)
    val propsOfOutput = scalaCompWithPriority.get.output.props.get
    val mergedProps = propsOfOutput.get("TestKey")
    assert(mergedProps.isDefined)
    val valuesOfprop = mergedProps.get.split(",")
    assert(valuesOfprop.size==3)
    assert(valuesOfprop.forall(_=="SET"))
  }

  behavior of "The scala MultiplicityTF executor with NO given priority"

  it must "run the multiplicity TF" in {
    // The same test as before but now the TF ruturn the inputs with the highest priority

   // Change all inputs do  trigger the TF
    val changedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getInitialAlarmState.set())).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithNoPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, true))

    // Clearing all must disable
    val clearedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getInitialAlarmState)).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaCompWithNoPriority.get.update(clearedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, false))

    val act1=activate(1)
    scalaCompWithNoPriority.get.update(act1)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, false))

    val act2=activate(2)
    scalaCompWithNoPriority.get.update(act2)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, false))

    val act3=activate(3)
    scalaCompWithNoPriority.get.update(act3)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, true))

    val act4=activate(4)
    scalaCompWithNoPriority.get.update(act4)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, true))

    // Activate all again
    scalaCompWithNoPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, true))

    // Clear all again
    scalaCompWithNoPriority.get.update(clearedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, false))
  }

  // The following is to test the validity of the output when some of the inputs
  // are valid and some invalid
  behavior of "The validity constraints of the output of the scala MultiplicityTF"

  it must "be not empty when enough SET inputs are reliable" in {
    // Change all inputs to SET to trigger the TF
    val changedMPs: Set[IASValue[?]] = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getInitialAlarmState.set())).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    // At the beginning all the inputs are UNRELIABLE
    changedMPs.foreach( value => {assert(value.iasValidity==IasValidity.UNRELIABLE)})
    scalaCompWithNoPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, true))
    assert(scalaCompWithNoPriority.get.output.validityConstraint.isEmpty)

    // Activate 3 (threshold) alarms so the output is still SET
    // but now SET alarms in input will be RELIABLE, UNSET UNRELIABLE
    // 
    // We expect the output to be SET and RELIABLE (unreliable unset ignored)
    val activated3 = activate(3)
    val activatedSetMPs = activated3.map( iasValue => {
      if (iasValue.asInstanceOf[IASValue[Alarm]].value.isSet()) setValidity(iasValue, IasValidity.RELIABLE)
      else setValidity(iasValue, IasValidity.UNRELIABLE)
    })
    scalaCompWithNoPriority.get.update(activatedSetMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, true))
    assert(scalaCompWithNoPriority.get.output.validityConstraint.nonEmpty)
    val constraintIds = scalaCompWithNoPriority.get.output.validityConstraint.get
    assert(constraintIds.size==3)
    assert(constraintIds.forall(checkValidity(activatedSetMPs,_,IasValidity.RELIABLE)))

    // Same test with 4 (>threshold) SET alarms
    val activated4 = activate(4)
    val activatedSetMPs4 = activated4.map( iasValue => {
      if (iasValue.asInstanceOf[IASValue[Alarm]].value.isSet()) setValidity(iasValue, IasValidity.RELIABLE)
      else setValidity(iasValue, IasValidity.UNRELIABLE)
    })
    scalaCompWithNoPriority.get.update(activatedSetMPs4)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, true))
    assert(scalaCompWithNoPriority.get.output.validityConstraint.nonEmpty)
    val constraintIds4 = scalaCompWithNoPriority.get.output.validityConstraint.get
    assert(constraintIds4.size==4)
    assert(constraintIds4.forall(checkValidity(activatedSetMPs4,_,IasValidity.RELIABLE)))
  }

  it must "be empty when not enough SET inputs are reliable" in {
    // Change all inputs to SET to trigger the TF
    val changedMPs: Set[IASValue[?]] = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getInitialAlarmState.set())).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    // At the beginning all the inputs are UNRELIABLE
    changedMPs.foreach( value => {assert(value.iasValidity==IasValidity.UNRELIABLE)})
    scalaCompWithNoPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, true))
    assert(scalaCompWithNoPriority.get.output.validityConstraint.isEmpty)

    // Activate 2 (threshold) alarms so the output is still SET
    // but now SET alarms in input will be RELIABLE, UNSET UNRELIABLE
    // 
    // We expect the output to be UNSET and RELIABLE (unreliable unset ignored)
    val activated2 = activate(2)
    val activatedSetMPs = activated2.map( iasValue => {
      if (iasValue.asInstanceOf[IASValue[Alarm]].value.isSet()) setValidity(iasValue, IasValidity.RELIABLE)
      else setValidity(iasValue, IasValidity.UNRELIABLE)
    })
    scalaCompWithNoPriority.get.update(activatedSetMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, false))
    assert(scalaCompWithNoPriority.get.output.validityConstraint.isEmpty)
  }

  it must "be non empty when enough UNSET inputs are reliable" in {
    // Change all inputs to SET to trigger the TF
    val changedMPs: Set[IASValue[?]] = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getInitialAlarmState.set())).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    // At the beginning all the inputs are UNRELIABLE
    changedMPs.foreach( value => {assert(value.iasValidity==IasValidity.UNRELIABLE)})
    scalaCompWithNoPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, true))
    assert(scalaCompWithNoPriority.get.output.validityConstraint.isEmpty)

    // Activate 2 (threshold) alarms so the output is still SET
    // but now UNSET alarms in input will be RELIABLE, UNSET UNRELIABLE
    // 
    // We expect the output to be UNSET and RELIABLE (unreliable unset ignored)
    val activated2 = activate(2)
    val activatedUnSetMPs = activated2.map( iasValue => {
      if (!iasValue.asInstanceOf[IASValue[Alarm]].value.isSet()) setValidity(iasValue, IasValidity.RELIABLE)
      else setValidity(iasValue, IasValidity.UNRELIABLE)
    })
    scalaCompWithNoPriority.get.update(activatedUnSetMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, false))
    assert(scalaCompWithNoPriority.get.output.validityConstraint.nonEmpty)
    val constraintIds2 = scalaCompWithNoPriority.get.output.validityConstraint.get
    assert(constraintIds2.size==3)
    assert(constraintIds2.forall(checkValidity(activatedUnSetMPs,_,IasValidity.RELIABLE)))

    // Same as before but with 4 RELIABLE UNSET inputs
    val activated1 = activate(1)
    val activatedUnSetMPs4 = activated1.map( iasValue => {
      if (!iasValue.asInstanceOf[IASValue[Alarm]].value.isSet()) setValidity(iasValue, IasValidity.RELIABLE)
      else setValidity(iasValue, IasValidity.UNRELIABLE)
    })
    scalaCompWithNoPriority.get.update(activatedUnSetMPs4)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, false))
    assert(scalaCompWithNoPriority.get.output.validityConstraint.nonEmpty)
    val constraintIds4 = scalaCompWithNoPriority.get.output.validityConstraint.get
    assert(constraintIds4.size==4)
    assert(constraintIds4.forall(checkValidity(activatedUnSetMPs4,_,IasValidity.RELIABLE)))
  }

  it must "be empty when not enough UNSET inputs are reliable" in {
    // Change all inputs to SET to trigger the TF
    val changedMPs: Set[IASValue[?]] = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getInitialAlarmState.set())).updateProdTStamp(System.currentTimeMillis()).toIASValue())
    // At the beginning all the inputs are UNRELIABLE
    changedMPs.foreach( value => {assert(value.iasValidity==IasValidity.UNRELIABLE)})
    scalaCompWithNoPriority.get.update(changedMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, true))
    assert(scalaCompWithNoPriority.get.output.validityConstraint.isEmpty)

    // Activate 3 (threshold) alarms so the output is still SET
    // but now UNSET alarms in input will be RELIABLE, SET UNRELIABLE
    // 
    // We expect the output to be UNSET and RELIABLE (unreliable unset ignored)
    val activated2 = activate(3)
    val activatedSetMPs = activated2.map( iasValue => {
      if (!iasValue.asInstanceOf[IASValue[Alarm]].value.isSet()) setValidity(iasValue, IasValidity.RELIABLE)
      else setValidity(iasValue, IasValidity.UNRELIABLE)
    })
    scalaCompWithNoPriority.get.update(activatedSetMPs)
    assert(checkAlarmActivation(scalaCompWithNoPriority.get, true))
    assert(scalaCompWithNoPriority.get.output.validityConstraint.isEmpty)
  }

  
}