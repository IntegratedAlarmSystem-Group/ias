package org.eso.ias.component.test

import org.scalatest.FlatSpec
import org.eso.ias.asce.transfer.impls.MultiplicityTF
import java.util.Properties
import org.eso.ias.asce.ComputingElement
import org.eso.ias.types.Alarm
import org.eso.ias.asce.transfer.ScalaTransfer
import org.eso.ias.asce.transfer.TransferFunctionLanguage
import org.eso.ias.asce.transfer.TransferFunctionSetting
import org.eso.ias.types.Identifier
import org.eso.ias.types.IdentifierType
import org.eso.ias.types.InOut
import org.eso.ias.types.IASTypes
import org.eso.ias.types.IASValue
import org.scalatest.BeforeAndAfterEach
import org.eso.ias.types.Validity
import org.eso.ias.types.IasValidity
import org.eso.ias.types.OperationalMode

/**
 * Test the multiplicity transfer function
 */
class TestMultiplicityTF extends FlatSpec with BeforeAndAfterEach {
  
  val props = new Properties()
  props.put(MultiplicityTF.ThresholdPropName,"3")
  props.put(MultiplicityTF.alarmPriorityPropName,Alarm.SET_LOW.toString())
  
  val threadFactory = new TestThreadFactory()
  
  /** The ID of the SUPERVISOR where the components runs */
  val supervId = new Identifier("SUPERV-ID",IdentifierType.SUPERVISOR,None)
  
  /** The ID of the DASU where the components runs */
  val dasId = new Identifier("DASU-ID",IdentifierType.DASU,supervId)

  /** The ID of the component running into the DASU */
  val compID = new Identifier("ASCE-ID",IdentifierType.ASCE,Option(dasId))
  
  /** The ID of the output generated by the component */
  val outId = new Identifier("MultiAlarm-ID",IdentifierType.IASIO, Some(compID))
  
  /** The output of the ASCE */
  val output: InOut[Alarm] = InOut.asOutput(outId,IASTypes.ALARM)
    
  /** The Map of IASValues for updating the inputs to the ASCE */
  val inputsMPs: Set[InOut[_]]  = {
    val v = for (i <- 1 to 5) yield {
    InOut.asInput(
        new Identifier(("INPUT-HIO-ID#"+i), IdentifierType.IASIO,compID),
        IASTypes.ALARM)  
    }
    v.toSet
  }
  
  // The threshold to assess the validity from the arrival time of the input
  val validityThresholdInSecs = 2
  
  /** The ASCE running the multiplicity TF */
  var scalaComp: Option[ComputingElement[Alarm]]= None
  
  override def beforeEach() {
  val scalaMultuiplicityTF = new TransferFunctionSetting(
      "org.eso.ias.asce.transfer.impls.MultiplicityTF",
        TransferFunctionLanguage.scala,
        None,
        threadFactory)
    
    scalaComp = Some(new ComputingElement[Alarm](
       compID,
       output,
       inputsMPs,
       scalaMultuiplicityTF,
       validityThresholdInSecs,
       props) with ScalaTransfer[Alarm])
    
    scalaComp.get.initialize()
    Thread.sleep(1000)
  }
  
  override def afterEach() {
    scalaComp.get.shutdown()
  }
  
  /**
   * Check the state of the alarm of the passed IASIO
   * 
   * @param hio: the IASIO to check the alarm state
   * @param alarmState: The expected alarm
   */
  def checkAlarmActivation(asce: ComputingElement[Alarm], alarmState: Alarm): Boolean = {
    assert(asce.isOutputAnAlarm)
    val iasio = asce.output
    assert(iasio.iasType==IASTypes.ALARM)
    
    iasio.value.forall(a => a==alarmState)
  }
  
  /**
   * Build and return a set of IASValue with a
   * defined number of ativated alarms 
   * 
   * @param the desired number of activated alarms
   * @param a set of alarms with n activaetd and the other cleared
   */
  def activate(n: Integer): Set[IASValue[_]] = {
    require(n>0)
    val inputsMPsList = inputsMPs.toList
    val list = for (i <- 0 to inputsMPsList.size-1) yield {
      if (i<=n-1) inputsMPsList(i).updateValue(Some(Alarm.getSetDefault)).updateDasuProdTStamp(System.currentTimeMillis()).toIASValue()
      else inputsMPsList(i).updateValue(Some(Alarm.CLEARED)).updateDasuProdTStamp(System.currentTimeMillis()).toIASValue()
    }
    val ret = list.toSet
    assert(ret.size==inputsMPs.size)
    assert(ret.count(value => value.value==Alarm.getSetDefault)==n)
    ret
  }
  
  behavior of "The scala MultiplicityTF executor"
  
  it must "Correctly load, init and shutdown the multiplicity TF executor" in { 
    val multuiplicityTF = new TransferFunctionSetting(
      "org.eso.ias.asce.transfer.impls.MultiplicityTF",
        TransferFunctionLanguage.scala,
        None,
        threadFactory)
    
    assert(!multuiplicityTF.initialized)
    assert(!multuiplicityTF.isShutDown)
    multuiplicityTF.initialize("ASCE-MinMaxTF-ID", "ASCE-running-ID", 1000, new Properties())
    Thread.sleep(500)
    assert(multuiplicityTF.initialized)
    assert(!multuiplicityTF.isShutDown)
    multuiplicityTF.shutdown()
    Thread.sleep(500)
    assert(multuiplicityTF.initialized)
    assert(multuiplicityTF.isShutDown)
  }
  
  it must "run the multiplicity TF" in {
    // Change all inputs do  trigger the TF
    val changedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.getSetDefault)).updateDasuProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaComp.get.update(changedMPs)
    assert(checkAlarmActivation(scalaComp.get,Alarm.SET_LOW))
    
    // Clearing all must disable
    val clearedMPs = inputsMPs.map ( iasio => iasio.updateValue(Some(Alarm.CLEARED)).updateDasuProdTStamp(System.currentTimeMillis()).toIASValue())
    scalaComp.get.update(clearedMPs)
    assert(checkAlarmActivation(scalaComp.get,Alarm.CLEARED))
    
    val act1=activate(1)
    scalaComp.get.update(act1)
    assert(checkAlarmActivation(scalaComp.get,Alarm.CLEARED))
    
    val act2=activate(2)
    scalaComp.get.update(act2)
    assert(checkAlarmActivation(scalaComp.get,Alarm.CLEARED))
    
    val act3=activate(3)
    scalaComp.get.update(act3)
    assert(checkAlarmActivation(scalaComp.get,Alarm.SET_LOW))
    
    val act4=activate(4)
    scalaComp.get.update(act4)
    assert(checkAlarmActivation(scalaComp.get,Alarm.SET_LOW))

    // Activate all again
    scalaComp.get.update(changedMPs)
    assert(checkAlarmActivation(scalaComp.get,Alarm.SET_LOW))
    
    // Clear all again
    scalaComp.get.update(clearedMPs)
    assert(checkAlarmActivation(scalaComp.get,Alarm.CLEARED))
  }
}