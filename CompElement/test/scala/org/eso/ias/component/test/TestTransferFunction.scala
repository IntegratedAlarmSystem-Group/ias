package org.eso.ias.component.test

import org.scalatest.FlatSpec
import org.eso.ias.types.InOut
import org.eso.ias.types.Identifier
import org.eso.ias.types.OperationalMode
import org.eso.ias.types.Validity
import org.eso.ias.asce.ComputingElement
import org.eso.ias.types.IASTypes
import scala.collection.mutable.{Map => MutableMap }
import org.eso.ias.asce.transfer.TransferFunctionSetting
import java.util.Properties
import org.eso.ias.asce.transfer.TransferFunctionLanguage
import java.util.concurrent.ScheduledThreadPoolExecutor
import org.eso.ias.asce.CompEleThreadFactory
import org.eso.ias.asce.AsceStates
import org.eso.ias.asce.transfer.JavaTransfer
import org.eso.ias.asce.transfer.ScalaTransfer
import org.eso.ias.types.IdentifierType
import org.eso.ias.types.Alarm
import org.eso.ias.logging.IASLogger
import org.eso.ias.types.IasValidity._
import org.eso.ias.types.IASValue
import org.eso.ias.types.IasValidity
import org.eso.ias.component.test.transfer.ConstraintValidityTF

class TestTransferFunction extends FlatSpec {
  
  /** The logger */
  private val logger = IASLogger.getLogger(this.getClass)
  
  def convert(iasios: Set[InOut[_]]): Set[IASValue[_]] = {
    iasios.map( io => io.toIASValue())
  }
  
  /**
   * Builds a Component with a set of inputs to test the transfer method
   */
  trait CompBuilder {
    
    val numOfInputs = 5
    
    /** The ID of the DASU where the components runs */
    val supervId = new Identifier("SupervId",IdentifierType.SUPERVISOR,None)
    val dasId = new Identifier("DAS-ID",IdentifierType.DASU,supervId)
    
    /** The ID of the component running into the DASU */
    val compID = new Identifier("COMP-ID",IdentifierType.ASCE,Option(dasId))
    
    // The ID of the output generated by the component
    val outId = new Identifier("OutputId",IdentifierType.IASIO,Option(compID))
    
    // Build the MP in output
    // The inherited validity is undefined 
    val output: InOut[Alarm] = InOut.asOutput(outId, IASTypes.ALARM)
      
    // The IDs of the monitor points in input 
    // to pass when building a Component
    val requiredInputIDs = (for (i <- 1 to numOfInputs)  yield ("ID"+i)).toList
    
    // Create numOfInputs MPs
    // with a inherited validity RELIABLE 
    var i=0 // To create different types of MPs
    val inputsMPs: MutableMap[String, InOut[_]] = MutableMap[String, InOut[_]]()
    for (id <- requiredInputIDs) {
      val mpId = new Identifier(id,IdentifierType.IASIO,Option(compID))
      i=i+1
      val mp = if ((i%2)==0) {
        InOut.asInput(mpId,IASTypes.ALARM).updateValue(Some(Alarm.CLEARED)).updateDasuProdTStamp(System.currentTimeMillis())
      } else {
        val mpVal = 1L
        InOut.asInput(mpId,IASTypes.LONG).updateValue(Some(1L)).updateDasuProdTStamp(System.currentTimeMillis())
      }
      inputsMPs+=(mp.id.id -> mp)
    }
    val threadFactory: CompEleThreadFactory = new CompEleThreadFactory("Test-runningId")
    
    // The threshold to assess the validity from the arrival time of the input
    val validityThresholdInSecs = 2
    
    // Instantiate on ASCE with a java TF implementation
    val javaTFSetting =new TransferFunctionSetting(
        "org.eso.ias.component.test.transfer.TransferExecutorImpl",
        TransferFunctionLanguage.java,
        None,
        threadFactory)
    val javaComp: ComputingElement[Alarm] = new ComputingElement[Alarm](
       compID,
       output,
       inputsMPs.values.toSet,
       javaTFSetting,
       validityThresholdInSecs,
       new Properties()) with JavaTransfer[Alarm]
    
    
    // Instantiate one ASCE with a scala TF implementation
    val scalaTFSetting =new TransferFunctionSetting(
        "org.eso.ias.component.test.transfer.TransferExample",
        TransferFunctionLanguage.scala,
        None,
        threadFactory)
    val scalaComp: ComputingElement[Alarm] = new ComputingElement[Alarm](
       compID,
       output,
       inputsMPs.values.toSet,
       scalaTFSetting,
       validityThresholdInSecs,
       new Properties()) with ScalaTransfer[Alarm]
    
     // Instantiate an ASCE with a scala TF implementation
    val brokenScalaTFSetting =new TransferFunctionSetting(
        "org.eso.ias.component.test.transfer.ThrowExceptionTF",
        TransferFunctionLanguage.scala,
        None,
        threadFactory)
    val brokenTFScalaComp: ComputingElement[Alarm] = new ComputingElement[Alarm](
       compID,
       output,
       inputsMPs.values.toSet,
       brokenScalaTFSetting,
       validityThresholdInSecs,
       new Properties()) with ScalaTransfer[Alarm]
    
    // Instantiate an ASCE to test the setting of thevalidity with constraints
    val validityConstraintTFSetting = new TransferFunctionSetting(
        "org.eso.ias.component.test.transfer.ConstraintValidityTF",
        TransferFunctionLanguage.scala,
        None,
        threadFactory)
    val constraintValidityId = new Identifier(ConstraintValidityTF.constraintSetterID,IdentifierType.IASIO,Option(compID))
    val constraintValidityScalaComponent: ComputingElement[Alarm] = new ComputingElement[Alarm](
       compID,
       output,
       inputsMPs.values.toSet+InOut.asInput(constraintValidityId,IASTypes.STRING),
       validityConstraintTFSetting,
       validityThresholdInSecs,
       new Properties()) with ScalaTransfer[Alarm]
  }
  
  behavior of "The Component transfer function"
  
  /**
   * This test checks if the validity is set to Reliable if all the
   * validity of the inputs have this level.
   */
  it must "set the validity of the output to the lower validity of the inputs" in new CompBuilder {
    logger.info("Validity from inputs test started")
    val component: ComputingElement[Alarm] = javaComp
    javaComp.initialize()
    assert(component.output.fromIasValueValidity.isEmpty, "The output does not inherit the validity from a IASValue" )
    
    val keys=inputsMPs.keys.toList.sorted
    val newChangedMp = inputsMPs.values.map(inout =>  inout.updateFromIasValueValidity(Validity(RELIABLE)))
    assert(newChangedMp.forall(iasio => iasio.fromInputsValidity.isEmpty))
    assert(newChangedMp.forall(iasio => iasio.fromIasValueValidity.isDefined))
    newChangedMp.foreach(iasio => println(">"+iasio.id.id+iasio.fromIasValueValidity.get.iasValidity))
    assert(newChangedMp.forall(iasio => iasio.fromIasValueValidity.get.iasValidity==RELIABLE))
    
    javaComp.update(convert(newChangedMp.toSet))
    assert(component.output.fromIasValueValidity.isEmpty)
    assert(component.output.fromInputsValidity.isDefined)
    assert(component.output.getValidity==Validity(IasValidity.RELIABLE))
    
    javaComp.shutdown()
  }
  
  it must "run the java TF executor" in new CompBuilder {
    assert(javaComp.initialize()==AsceStates.InputsUndefined)
    // Send all the possible inputs to check if the state changes and the ASCE runs the TF
    inputsMPs.keys.foreach( k => {
      val inout = inputsMPs(k)
      val newIasio = if (inout.iasType==IASTypes.ALARM) inout.updateValue(Some(Alarm.getSetDefault))
        else inout.updateValue(Some(-5L))
      inputsMPs(k)=newIasio
    })
    
    // Send all the inputs
    val result = javaComp.update(convert(inputsMPs.values.toSet))
    assert(result._2==AsceStates.Healthy)
    assert(result._1.isDefined)
    assert(result._1.get.value.isDefined)
    
    javaComp.shutdown()
    val out = javaComp.output
    assert(out.value.isDefined)
    logger.info("Actual value = {}",out.value.toString())
    val alarm = out.value.get.asInstanceOf[Alarm]
    assert(alarm==Alarm.getSetDefault)
  }
  
  it must "run the scala TF executor" in new CompBuilder {
    assert(scalaComp.initialize()==AsceStates.InputsUndefined)
    
    // Send all the possible inputs to check if the state changes and the ASCE runs the TF
    inputsMPs.keys.foreach( k => {
      val inout = inputsMPs(k)
      val newIasio = if (inout.iasType==IASTypes.ALARM) inout.updateValue(Some(Alarm.getSetDefault))
        else inout.updateValue(Some(-5L))
      inputsMPs(k)=newIasio
    })
    
    // Send the inputs
    val result = scalaComp.update(convert(inputsMPs.values.toSet))
    println("XXXX "+result._2.toString())
    assert(result._2==AsceStates.Healthy)
    
    scalaComp.shutdown()
    
    logger.info("Actual value = {}",scalaComp.output.value.toString())
    val alarm = scalaComp.output.value.get
    assert(alarm==Alarm.getSetDefault)
  }
  
  it must "detect a broken scala TF executor" in new CompBuilder {
    brokenTFScalaComp.initialize()
    assert(brokenTFScalaComp.getState()==AsceStates.InputsUndefined)
    // Send all the possible inputs to check if the state changes and the ASCE runs the TF
    inputsMPs.keys.foreach( k => {
      val inout = inputsMPs(k)
      val newIasio = if (inout.iasType==IASTypes.ALARM) inout.updateValue(Some(Alarm.getSetDefault))
        else inout.updateValue(Some(-5L))
      inputsMPs(k)=newIasio
    })
    
    // Send the inputs and get the result
    val result = brokenTFScalaComp.update(convert(inputsMPs.values.toSet))
    assert(result._2==AsceStates.TFBroken)
    assert(brokenTFScalaComp.getState()==AsceStates.TFBroken)
    
    brokenTFScalaComp.shutdown()
  }
  
  it must "set the validity constraints" in new CompBuilder {
    logger.info("Checking the validity constraints")
    constraintValidityScalaComponent.initialize()
    
    logger.info("Inputs of ASCE {}",constraintValidityScalaComponent.inputs.values.map(_.id.id).mkString(","))

    val selectorInput = constraintValidityScalaComponent.inputs(ConstraintValidityTF.constraintSetterID)
    assert(selectorInput.id.id==ConstraintValidityTF.constraintSetterID)
    
    // Empty String
    val empty=selectorInput.updateValue(Some("")).updateDasuProdTStamp(System.currentTimeMillis())
    // Send the inputs and get the result
    val result = constraintValidityScalaComponent.update(convert(inputsMPs.values.toSet+empty))
    assert(result._1.isDefined)
    assert(!result._1.get.validityConstraint.isDefined)
    assert(result._2==AsceStates.Healthy)
    
    // Valid constraint with one ID
    val oneId = selectorInput.updateValue(Some("ID2")).updateDasuProdTStamp(System.currentTimeMillis())
    // Send the inputs and get the result
    val resultOneId = constraintValidityScalaComponent.update(convert(inputsMPs.values.toSet+oneId))
    assert(resultOneId._1.isDefined)
    assert(resultOneId._1.get.validityConstraint.isDefined)
    assert(resultOneId._1.get.validityConstraint.get.size==1)
    assert(resultOneId._2==AsceStates.Healthy)
    
    // Valid constraint with more IDs
    val moreIds = selectorInput.updateValue(Some("ID1,ID3,ID4")).updateDasuProdTStamp(System.currentTimeMillis())
    // Send the inputs and get the result
    val resultMoreIds = constraintValidityScalaComponent.update(convert(inputsMPs.values.toSet+moreIds))
    assert(resultMoreIds._1.isDefined)
    assert(resultMoreIds._1.get.validityConstraint.isDefined)
    assert(resultMoreIds._1.get.validityConstraint.get.size==3)
    assert(resultMoreIds._2==AsceStates.Healthy)
    
    constraintValidityScalaComponent.shutdown()
  }
  
  it must "stop running the TF with invalid constraints" in new CompBuilder {
    constraintValidityScalaComponent.initialize()
    
    // Empty String
    val invalid= constraintValidityScalaComponent.inputs(ConstraintValidityTF.constraintSetterID).updateValue(Some("NotDefinedID"))
    // Send the inputs and get the result
    val result = constraintValidityScalaComponent.update(convert(inputsMPs.values.toSet+invalid))
    assert(result._2==AsceStates.TFBroken)
    
    constraintValidityScalaComponent.shutdown()
    
  }
  
  /**
   * This test does not take into account the validity by time because
   * the timestamp of all the inputs are updated when setting the new value
   */
  it must "set the validity according to the constraints" in new CompBuilder {
    constraintValidityScalaComponent.initialize()
    
    val selectorInput = constraintValidityScalaComponent.inputs(ConstraintValidityTF.constraintSetterID)
    assert(selectorInput.id.id==ConstraintValidityTF.constraintSetterID)
    
    // Consider only the validity of the LONG (odd ID)
    val moreIds = selectorInput.updateValue(Some("ID1,ID3,ID5")).updateDasuProdTStamp(System.currentTimeMillis())
    // Send the inputs and get the result
    val resultMoreIds = constraintValidityScalaComponent.update(convert(inputsMPs.values.toSet+moreIds))
    logger.info("The TF returned with {} validity from inputs",resultMoreIds._1.get.fromInputsValidity)
    assert(resultMoreIds._1.isDefined)
    assert(resultMoreIds._1.get.validityConstraint.isDefined)
    assert(resultMoreIds._1.get.validityConstraint.get.size==3)
    assert(resultMoreIds._2==AsceStates.Healthy)
    assert(resultMoreIds._1.get.fromInputsValidity.isDefined)
    assert(resultMoreIds._1.get.fromInputsValidity.get.iasValidity==UNRELIABLE)
    
    // Change the validity of the three inputs of the constraints
    // that must change the validity of the output
    val id1 = constraintValidityScalaComponent.inputs("ID1").updateValueValidity(Some(1L), Some(Validity(IasValidity.RELIABLE)))
    val id3 = constraintValidityScalaComponent.inputs("ID3").updateValueValidity(Some(3L), Some(Validity(IasValidity.RELIABLE)))
    val id5 = constraintValidityScalaComponent.inputs("ID5").updateValueValidity(Some(5L), Some(Validity(IasValidity.RELIABLE)))
    
    val resultWintConstraints = constraintValidityScalaComponent.update(convert(Set(id1,id3,id5,moreIds)))
    logger.info("The TF returned with {} validity from inputs",resultWintConstraints._1.get.fromInputsValidity)
    assert(resultWintConstraints._1.isDefined)
    assert(resultWintConstraints._1.get.validityConstraint.isDefined)
    assert(resultWintConstraints._1.get.validityConstraint.get.size==3)
    assert(resultWintConstraints._2==AsceStates.Healthy)
    assert(resultWintConstraints._1.get.fromInputsValidity.isDefined)
    assert(resultWintConstraints._1.get.fromInputsValidity.get.iasValidity==RELIABLE)
    
    constraintValidityScalaComponent.shutdown()
  }
  
  /**
   * This test does take into account the validity by time
   */
  it must "set the validity according to the constraints and time of inputs" in new CompBuilder {
    constraintValidityScalaComponent.initialize()
    
    val selectorInput = constraintValidityScalaComponent.inputs(ConstraintValidityTF.constraintSetterID)
    assert(selectorInput.id.id==ConstraintValidityTF.constraintSetterID)
    
    // Consider only the validity of the LONG (odd ID)
    val moreIds = selectorInput.updateValue(Some("ID1,ID3,ID5")).updateDasuProdTStamp(System.currentTimeMillis())
    // Send the inputs and get the result
    val resultMoreIds = constraintValidityScalaComponent.update(convert(inputsMPs.values.toSet+moreIds))
    logger.info("The TF returned with {} validity from inputs",resultMoreIds._1.get.fromInputsValidity)
    assert(resultMoreIds._1.isDefined)
    assert(resultMoreIds._1.get.validityConstraint.isDefined)
    assert(resultMoreIds._1.get.validityConstraint.get.size==3)
    assert(resultMoreIds._2==AsceStates.Healthy)
    assert(resultMoreIds._1.get.fromInputsValidity.isDefined)
    assert(resultMoreIds._1.get.fromInputsValidity.get.iasValidity==UNRELIABLE)
    
    // Change the validity of the three inputs of the constraints
    // that must change the validity of the output
    val id1 = constraintValidityScalaComponent.inputs("ID1").updateValueValidity(Some(1L), Some(Validity(IasValidity.RELIABLE)))
    val id3 = constraintValidityScalaComponent.inputs("ID3").updateValueValidity(Some(3L), Some(Validity(IasValidity.RELIABLE)))
    val id5 = constraintValidityScalaComponent.inputs("ID5").updateValueValidity(Some(5L), Some(Validity(IasValidity.RELIABLE)))
    
    val resultWintConstraints = constraintValidityScalaComponent.update(convert(Set(id1,id3,id5,moreIds)))
    logger.info("The TF returned with {} validity from inputs",resultWintConstraints._1.get.fromInputsValidity)
    assert(resultWintConstraints._1.isDefined)
    assert(resultWintConstraints._1.get.validityConstraint.isDefined)
    assert(resultWintConstraints._1.get.validityConstraint.get.size==3)
    assert(resultWintConstraints._2==AsceStates.Healthy)
    assert(resultWintConstraints._1.get.fromInputsValidity.isDefined)
    assert(resultWintConstraints._1.get.fromInputsValidity.get.iasValidity==RELIABLE)
    
    // Now One of the inputs, id3WithDealy, has not been refreshed in timne
    logger.info("Giving time to invalidate one of the inputs")
    Thread.sleep((validityThresholdInSecs+1)*1000)
    val id1WithDealy = id1.updateValue(Some(10L)).updateDasuProdTStamp(System.currentTimeMillis())
    val id3WithDealy = id3.updateValue(Some(15L)) // Do not update the production time
    val id5WithDealy = id5.updateValue(Some(20L)).updateDasuProdTStamp(System.currentTimeMillis())
    val resultWintConstraintsAnddelays = constraintValidityScalaComponent.update(convert(Set(id1WithDealy,id3WithDealy,id5WithDealy)))
    logger.info("The TF returned with {} validity from inputs",resultWintConstraintsAnddelays._1.get.fromInputsValidity)
    assert(resultWintConstraintsAnddelays._1.isDefined)
    assert(resultWintConstraintsAnddelays._1.get.validityConstraint.isDefined)
    assert(resultWintConstraintsAnddelays._1.get.validityConstraint.get.size==3)
    assert(resultWintConstraintsAnddelays._2==AsceStates.Healthy)
    assert(resultWintConstraintsAnddelays._1.get.fromInputsValidity.isDefined)
    assert(resultWintConstraintsAnddelays._1.get.fromInputsValidity.get.iasValidity==UNRELIABLE)
    
    // Now restore the time stamps and check again
    val id3WithDeleay2 = id3.updateValue(Some(30L)).updateDasuProdTStamp(System.currentTimeMillis())
    val dealayFixedResult = constraintValidityScalaComponent.update(convert(Set(id3WithDeleay2)))
    logger.info("The TF returned with {} validity from inputs",dealayFixedResult._1.get.fromInputsValidity)
    assert(dealayFixedResult._1.isDefined)
    assert(dealayFixedResult._1.get.validityConstraint.isDefined)
    assert(dealayFixedResult._1.get.validityConstraint.get.size==3)
    assert(dealayFixedResult._2==AsceStates.Healthy)
    assert(dealayFixedResult._1.get.fromInputsValidity.isDefined)
    assert(dealayFixedResult._1.get.fromInputsValidity.get.iasValidity==RELIABLE)
    
    constraintValidityScalaComponent.shutdown()
  }
  
}
