package org.eso.ias.component.test

import org.scalatest.FlatSpec
import org.eso.ias.prototype.input.InOut
import org.eso.ias.prototype.input.Identifier
import org.eso.ias.prototype.input.java.OperationalMode
import org.eso.ias.prototype.input.Validity
import org.eso.ias.prototype.compele.ComputingElement
import org.eso.ias.prototype.input.java.IASTypes
import scala.collection.mutable.{Map => MutableMap }
import org.eso.ias.prototype.transfer.TransferFunctionSetting
import java.util.Properties
import org.eso.ias.prototype.transfer.TransferFunctionLanguage
import java.util.concurrent.ScheduledThreadPoolExecutor
import org.eso.ias.prototype.compele.CompEleThreadFactory
import org.eso.ias.prototype.compele.AsceStates
import org.eso.ias.prototype.transfer.JavaTransfer
import org.eso.ias.prototype.transfer.ScalaTransfer
import org.eso.ias.prototype.input.java.IdentifierType
import org.eso.ias.prototype.input.java.AlarmSample
import org.ias.prototype.logging.IASLogger
import org.eso.ias.prototype.input.java.IasValidity._

class TestTransferFunction extends FlatSpec {
  
  /**
   * Builds a Component with a set of inputs to test the transfer method
   */
  trait CompBuilder {
    
    val numOfInputs = 5
    
    /** The ID of the DASU where the components runs */
    val supervId = new Identifier("SupervId",IdentifierType.SUPERVISOR,None)
    val dasId = new Identifier("DAS-ID",IdentifierType.DASU,supervId)
    
    /** The ID of the component running into the DASU */
    val compID = new Identifier("COMP-ID",IdentifierType.ASCE,Option(dasId))
    
    // The refresh rate of the component
    val mpRefreshRate = InOut.MinRefreshRate+500
    
    // The ID of the output generated by the component
    val outId = new Identifier("OutputId",IdentifierType.IASIO,Option(compID))
    // Build the MP in output
    val output: InOut[AlarmSample] = new InOut[AlarmSample](
      Option.empty,
      System.currentTimeMillis(),
      outId,
      mpRefreshRate, 
      OperationalMode.OPERATIONAL,
      Validity(UNRELIABLE), IASTypes.ALARM)
      
    // The IDs of the monitor points in input 
    // to pass when building a Component
    val requiredInputIDs = (for (i <- 1 to numOfInputs)  yield ("ID"+i)).toList
    
    // Create numOfInputs MPs
    var i=0 // To create different types of MPs
    val inputsMPs: MutableMap[String, InOut[_]] = MutableMap[String, InOut[_]]()
    for (id <- requiredInputIDs) {
      val mpId = new Identifier(id,IdentifierType.IASIO,Option(compID))
      i=i+1
      val mp = if ((i%2)==0) {
        new InOut[AlarmSample](
          Option.empty,
          System.currentTimeMillis(),
          mpId,
          mpRefreshRate,
          OperationalMode.OPERATIONAL,
          UNRELIABLE, IASTypes.ALARM)
      } else {
        val mpVal = 1L
        new InOut[Long](
          Some(mpVal),
          System.currentTimeMillis(),
          mpId,
          mpRefreshRate,
          OperationalMode.OPERATIONAL,
          UNRELIABLE, IASTypes.LONG)
      }
      inputsMPs+=(mp.id.id -> mp)
    }
    val threadFactory: CompEleThreadFactory = new CompEleThreadFactory("Test-runningId")
    
    // Instantiate on ASCE with a java TF implementation
    val javaTFSetting =new TransferFunctionSetting(
        "org.eso.ias.component.test.transfer.TransferExecutorImpl",
        TransferFunctionLanguage.java,
        threadFactory)
    val javaComp: ComputingElement[AlarmSample] = new ComputingElement[AlarmSample](
       compID,
       output,
       inputsMPs.values.toSet,
       javaTFSetting,
       new Properties()) with JavaTransfer[AlarmSample]
    
    
    // Instantiate one ASCE with a scala TF implementation
    val scalaTFSetting =new TransferFunctionSetting(
        "org.eso.ias.component.test.transfer.TransferExample",
        TransferFunctionLanguage.scala,
        threadFactory)
    val scalaComp: ComputingElement[AlarmSample] = new ComputingElement[AlarmSample](
       compID,
       output,
       inputsMPs.values.toSet,
       scalaTFSetting,
       new Properties()) with ScalaTransfer[AlarmSample]
    
     // Instantiate one ASCE with a scala TF implementation
    val brokenScalaTFSetting =new TransferFunctionSetting(
        "org.eso.ias.component.test.transfer.ThrowExceptionTF",
        TransferFunctionLanguage.scala,
        threadFactory)
    val brokenTFScalaComp: ComputingElement[AlarmSample] = new ComputingElement[AlarmSample](
       compID,
       output,
       inputsMPs.values.toSet,
       brokenScalaTFSetting,
       new Properties()) with ScalaTransfer[AlarmSample]
  }
  
  /** The logger */
  private val logger = IASLogger.getLogger(this.getClass)
  
  behavior of "The Component transfer function"
  
  /**
   * This test checks if the validity is set to Reliable if all the
   * validities have this level.
   */
  it must "set the validity to the lower value" in new CompBuilder {
    val component: ComputingElement[AlarmSample] = javaComp
    javaComp.initialize()
    assert(component.output.validity==Validity(UNRELIABLE))
    
    val keys=inputsMPs.keys.toList.sorted
    val newChangedMp = inputsMPs.values.map(inout =>  inout.updateValidity(Validity(RELIABLE)))
    newChangedMp.foreach(i => logger.info("Submitting {} with validity {}",i.id.id,i.validity.toString()))
    javaComp.update(newChangedMp.toList)
    javaComp.shutdown()
    assert(component.output.validity==Validity(RELIABLE))
  }
  
  it must "run the java TF executor" in new CompBuilder {
    assert(javaComp.initialize()==AsceStates.InputsUndefined)
    // Send all the possible inputs to check if the state changes and the ASCE runs the TF
    inputsMPs.keys.foreach( k => {
      val inout = inputsMPs(k)
      val newIasio = if (inout.iasType==IASTypes.ALARM) inout.update(Option(AlarmSample.SET), RELIABLE)
        else inout.update(Option(-5L), RELIABLE)
      inputsMPs(k)=newIasio
    })
    
    // Send the inputs
    val result = javaComp.update(inputsMPs.values.toList)
    assert(result._2==AsceStates.Healthy)
    
    javaComp.shutdown()
    logger.info("Actual value = {}",javaComp.output.value.toString())
    val alarm = javaComp.output.value.get.asInstanceOf[AlarmSample]
    assert(alarm==AlarmSample.SET)
  }
  
  it must "run the scala TF executor" in new CompBuilder {
    assert(scalaComp.initialize()==AsceStates.InputsUndefined)
    
    // Send all the possible inputs to check if the state changes and the ASCE runs the TF
    inputsMPs.keys.foreach( k => {
      val inout = inputsMPs(k)
      val newIasio = if (inout.iasType==IASTypes.ALARM) inout.update(Option(AlarmSample.SET), RELIABLE)
        else inout.update(Option(-5L), RELIABLE)
      inputsMPs(k)=newIasio
    })
    
    // Send the inputs
    val result = scalaComp.update(inputsMPs.values.toList)
    assert(result._2==AsceStates.Healthy)
    
    scalaComp.shutdown()
    
    logger.info("Actual value = {}",scalaComp.output.value.toString())
    val alarm = scalaComp.output.value.get.asInstanceOf[AlarmSample]
    assert(alarm==AlarmSample.SET)
  }
  
  it must "detect a broken scala TF executor" in new CompBuilder {
    brokenTFScalaComp.initialize()
    assert(brokenTFScalaComp.getState()==AsceStates.InputsUndefined)
    // Send all the possible inputs to check if the state changes and the ASCE runs the TF
    inputsMPs.keys.foreach( k => {
      val inout = inputsMPs(k)
      val newIasio = if (inout.iasType==IASTypes.ALARM) inout.update(Option(AlarmSample.SET), RELIABLE)
        else inout.update(Option(-5L), RELIABLE)
      inputsMPs(k)=newIasio
    })
    
    // Send the inputs and get the result
    val result = brokenTFScalaComp.update(inputsMPs.values.toList)
    assert(result._2==AsceStates.TFBroken)
    assert(brokenTFScalaComp.getState()==AsceStates.TFBroken)
    
    brokenTFScalaComp.shutdown()
  }
  
}
