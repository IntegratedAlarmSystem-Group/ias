package org.eso.ias.component.test

import org.scalatest.FlatSpec
import org.eso.ias.prototype.input.Identifier
import org.eso.ias.prototype.input.AlarmValue
import org.eso.ias.prototype.input.java.OperationalMode
import org.eso.ias.prototype.input.Validity
import org.eso.ias.prototype.input.AlarmState
import org.eso.ias.prototype.input.AckState
import scala.collection.mutable.HashMap
import org.eso.ias.prototype.input.java.IASTypes
import org.eso.ias.prototype.input.InOut
import scala.collection.mutable.{Map => MutableMap }
import org.eso.ias.prototype.transfer.TransferFunctionSetting
import org.eso.ias.prototype.transfer.TransferFunctionLanguage
import java.util.Properties
import org.eso.ias.prototype.compele.CompEleThreadFactory
import org.eso.ias.prototype.compele.ComputingElement
import org.eso.ias.prototype.transfer.ScalaTransfer
import org.eso.ias.prototype.transfer.JavaTransfer

/**
 * Test the basic functionalities of the IAS Component,
 * while the functioning of the transfer function
 * is checked elsewhere.
 */
class TestComponent extends FlatSpec {
  // The ID of the output generated by the component
  val outId = new Identifier(Some[String]("OutputId"), None)
  
  // The ID of the DAS where the components runs
  val dasId = new Identifier(Some[String]("DAS-ID"),None)
  
  // The ID of the component to test
  val compId = new Identifier(Some[String]("ComponentId"), Option[Identifier](dasId))
  
  val mpRefreshRate = InOut.MinRefreshRate+50
  
  // The IDs of the monitor points in input 
  // to pass when building a Component
  val requiredInputIDs = List("ID1", "ID2")
  
  // The ID of the first MP
  val mpI1Identifier = new Identifier(Some[String](requiredInputIDs(0)), Option[Identifier](compId))
  val mp1 = InOut[AlarmValue](
      None,
      mpI1Identifier,
      mpRefreshRate,
      OperationalMode.UNKNOWN,
      Validity.Unreliable,
      IASTypes.ALARM)
  
  // The ID of the second MP
  val mpI2Identifier = new Identifier(Some[String](requiredInputIDs(1)), Option[Identifier](compId))
  val mp2 = InOut[AlarmValue](
      None,
      mpI2Identifier,
      mpRefreshRate,
      OperationalMode.UNKNOWN,
      Validity.Unreliable,
      IASTypes.ALARM)
  val actualInputs: MutableMap[String, InOut[_]] = MutableMap(mp1.id.id.get -> mp1,mp2.id.id.get -> mp2)
  
  behavior of "A Component"
  
  it must "be correctly initialized" in {
    val output = InOut[AlarmValue](
      None,
      outId,
      mpRefreshRate,
      OperationalMode.UNKNOWN,
      Validity.Unreliable,
      IASTypes.ALARM)
    
    val threadaFactory = new CompEleThreadFactory("Test-runninId")
    val tfSetting =new TransferFunctionSetting(
        "org.eso.ias.prototype.transfer.TransferExecutorImpl",
        TransferFunctionLanguage.java,
        threadaFactory)
    val comp: ComputingElement[AlarmValue] = new ComputingElement[AlarmValue](
       compId,
       output,
       requiredInputIDs,
       actualInputs,
       tfSetting,
       Some[Properties](new Properties())) with JavaTransfer[AlarmValue]
    
    assert(comp.id==compId)
    assert(comp.inputs.size==requiredInputIDs.size)
    assert(comp.output.id==outId)
  }
  
  it must "skip to shelve a None AlarmValue" in {
    val output = InOut[AlarmValue](
      None,
      outId,
      mpRefreshRate,
      OperationalMode.UNKNOWN,
      Validity.Unreliable,
      IASTypes.ALARM)
      
    val threadFactory = new CompEleThreadFactory("Test-runninId")
    val tfSetting =new TransferFunctionSetting(
        "org.eso.ias.prototype.transfer.TransferExecutorImpl",
        TransferFunctionLanguage.java,
        threadFactory)
    val comp: ComputingElement[AlarmValue] = new ComputingElement[AlarmValue](
       compId,
       output,
       requiredInputIDs,
       actualInputs,
       tfSetting,
       Some[Properties](new Properties())) with JavaTransfer[AlarmValue]
    comp.shelve(true);
    assert(comp.output.actualValue.value.isEmpty)
  }
  
  it must "skip to shelve a Non-AlarmValue output" in {
    val output = InOut[Long](
      None,
      outId,
      mpRefreshRate,
      OperationalMode.UNKNOWN,
      Validity.Unreliable,
      IASTypes.LONG)
      
    val threadFactory = new CompEleThreadFactory("Test-runninId")
    val tfSetting =new TransferFunctionSetting(
        "org.eso.ias.prototype.transfer.TransferExecutorImpl",
        TransferFunctionLanguage.java,
        threadFactory)
    val comp: ComputingElement[Long] = new ComputingElement[Long](
       compId,
       output,
       requiredInputIDs,
       actualInputs,
       tfSetting,
       Some[Properties](new Properties())) with JavaTransfer[Long]
    comp.shelve(true);
    assert(comp.output.actualValue.value.isEmpty)
  }
  
  it must "shelve AlarmValue output" in {
    val alarmVal = new AlarmValue(AlarmState.Active,false,AckState.Acknowledged)
    val output = InOut(
      Some(alarmVal),
      outId,
      mpRefreshRate,
      OperationalMode.OPERATIONAL,
      Validity.Unreliable,
      IASTypes.ALARM)
    val threadFactory = new CompEleThreadFactory("Test-runninId")  
    val tfSetting =new TransferFunctionSetting(
        "org.eso.ias.prototype.transfer.TransferExecutorImpl",
        TransferFunctionLanguage.java,
        threadFactory)
    val comp: ComputingElement[AlarmValue] = new ComputingElement[AlarmValue](
       compId,
       output,
       requiredInputIDs,
       actualInputs,
       tfSetting,
       Some[Properties](new Properties())) with JavaTransfer[AlarmValue]
    
    comp.shelve(true);
    
    val shelvedVal = comp.output.actualValue.value.get.asInstanceOf[AlarmValue]
    assert(shelvedVal.shelved)
    
  }
  
  it must "skip to ack a None AlarmValue" in {
    val output = InOut[AlarmValue](
      None,
      outId,
      mpRefreshRate,
      OperationalMode.UNKNOWN,
      Validity.Unreliable,
      IASTypes.ALARM)
    
    val threadFactory = new CompEleThreadFactory("Test-runninId")
    val tfSetting =new TransferFunctionSetting(
        "org.eso.ias.prototype.transfer.TransferExecutorImpl",
        TransferFunctionLanguage.java,
        threadFactory)
    val comp: ComputingElement[AlarmValue]= new ComputingElement[AlarmValue](
       compId,
       output,
       requiredInputIDs,
       actualInputs,
       tfSetting,
       Some[Properties](new Properties())) with JavaTransfer[AlarmValue]
    comp.ack();
    assert(comp.output.actualValue.value.isEmpty) 
  }
  
  it must "skip to ack a Non-AlarmValue output" in {
    val output = InOut[Long](
      None,
      outId,
      mpRefreshRate,
      OperationalMode.UNKNOWN,
      Validity.Unreliable,
      IASTypes.LONG)
      
    val threadFactory = new CompEleThreadFactory("Test-runninId")
    val tfSetting =new TransferFunctionSetting(
        "org.eso.ias.prototype.transfer.TransferExecutorImpl",
        TransferFunctionLanguage.java,
        threadFactory)
    val comp: ComputingElement[Long] = new ComputingElement[Long](
       compId,
       output,
       requiredInputIDs,
       actualInputs,
       tfSetting,
       Some[Properties](new Properties())) with JavaTransfer[Long]
    comp.ack() 
    assert(comp.output.actualValue.value.isEmpty)
  }
  
  it must "ack an AlarmValue output" in {
    val alarmVal = new AlarmValue(AlarmState.Active,false,AckState.Acknowledged)
    val output = InOut(
      Some(alarmVal),
      outId,
      mpRefreshRate,
      OperationalMode.OPERATIONAL,
      Validity.Unreliable,
      IASTypes.ALARM)
    
    val threadFactory = new CompEleThreadFactory("Test-runninId")
    val tfSetting =new TransferFunctionSetting(
        "org.eso.ias.prototype.transfer.TransferExecutorImpl",
        TransferFunctionLanguage.java,
        threadFactory)
    val comp: ComputingElement[AlarmValue] = new ComputingElement[AlarmValue](
       compId,
       output,
       requiredInputIDs,
       actualInputs,
       tfSetting,
       Some[Properties](new Properties())) with JavaTransfer[AlarmValue]
    
    comp.ack()
    
    val ackedVal = comp.output.actualValue.value.get.asInstanceOf[AlarmValue]
    assert(ackedVal.acknowledgement==AckState.Acknowledged)
  }
  
}
