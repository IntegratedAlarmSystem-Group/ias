package org.eso.ias.basictypes.test

import org.scalatest.FlatSpec
import org.eso.ias.types.Identifier
import org.eso.ias.types.IdentifierType

/**
 * Test the identifier but not the identifier generated by a template
 * that tested elsewhere
 */
class TestIdentifier extends FlatSpec {
  behavior of "A Identifier"
  
  it must "forbid to declare IDs with null or empty strings" in {
    assertThrows[IllegalArgumentException] {
      val id1: Identifier = new Identifier(null,null,None)
    }
    assertThrows[IllegalArgumentException] {
      val id2: Identifier = new Identifier("",IdentifierType.MONITORED_SOFTWARE_SYSTEM,None)
    }
  }
  
  it must "forbid to declare IDs containing the separator char '"+Identifier.separator+"'" in {
    val wrongID = "Prefix"+Identifier.separator+"-suffix"
    assertThrows[IllegalArgumentException] {
      val id1: Identifier = new Identifier(wrongID,IdentifierType.ASCE,None)
    }
  }
  
  it must "forbid to instantiate a ID with a parent of the wrong type" in {
    val msId=new Identifier("monSysyId",IdentifierType.MONITORED_SOFTWARE_SYSTEM,None)
    
    val supervId = new Identifier("SupervId",IdentifierType.SUPERVISOR,None)
    val dasuId = new Identifier("dasuId",IdentifierType.DASU,supervId)
    
    val plId=new Identifier("pluginId",IdentifierType.PLUGIN,Option(msId))
    val convId=new Identifier("converterId",IdentifierType.CONVERTER,Some(plId))
    val ioId=new Identifier("iasioId",IdentifierType.IASIO,Option(convId))
    
    assertThrows[IllegalArgumentException] {
      val ioId2=new Identifier("iasioId",IdentifierType.IASIO,Option(plId))
    }
    
  }
  
  /**
   * Check the construction of the runningID.
   */
  it must "provide a non-empty runningID string" in {
    val id1=new Identifier("monSysyId",IdentifierType.MONITORED_SOFTWARE_SYSTEM,None)
    val id2=new Identifier("pluginId",IdentifierType.PLUGIN,Option(id1))
    val id3: Identifier = new Identifier("converterId",IdentifierType.CONVERTER,Some(id2))
    assert(!id3.runningID.isEmpty())
    val id4: Identifier = new Identifier("iasioId",IdentifierType.IASIO,Option(id3))
    assert(!id4.runningID.isEmpty())

    assert(id4.runningID.contains(id4.id))
    assert(id4.runningID.contains(id3.id))
    assert(id4.runningID.contains(id1.id))
    assert(id4.runningID.contains(id2.id))
  }
  
  /**
   * Check the construction of the fullRunningID.
   */
  it must "provide a non-empty fullRunningID string" in {
    val id1=new Identifier("monSysyId",IdentifierType.MONITORED_SOFTWARE_SYSTEM,None)
    val id2=new Identifier("pluginId",IdentifierType.PLUGIN,Option(id1))
    val id3: Identifier = new Identifier("converterId",IdentifierType.CONVERTER,Some(id2))
    assert(!id3.fullRunningID.isEmpty())
    assert(id3.fullRunningID.contains(id3.id))
    assert(id3.fullRunningID.contains(id3.id))
    assert(id3.fullRunningID.contains(id3.id))
  }
  
  /**
   * Check the construction of the runningID.
   */
  it must "must properly order the runnigID" in {
    val id1: Identifier = new Identifier("supervId",IdentifierType.SUPERVISOR,None)
    val id2: Identifier = new Identifier("dasuId",IdentifierType.DASU,Option(id1))
    val id3: Identifier = new Identifier("asceId",IdentifierType.ASCE,Option(id2))
    val id4: Identifier = new Identifier("iasioId",IdentifierType.IASIO,Option(id3))
    
    assert(!id4.runningID.isEmpty())
    assert(id4.runningID.endsWith(id4.id))
    assert(id4.runningID.startsWith(id1.id))
    
  }
  
  it must "implement equals" in {
    // The IDs of dependents
    val supervId1 = new Identifier("SupervId1",IdentifierType.SUPERVISOR,None)
    val dasuId1 = new Identifier("dasuVID1",IdentifierType.DASU,supervId1)
    val asceId1 = new Identifier("asceVID1",IdentifierType.ASCE,Option(dasuId1))      
    val depId1 = new Identifier("AlarmID1",IdentifierType.IASIO,Option[Identifier](asceId1))
    
    val tempId = Identifier(depId1.fullRunningID)
    assert(tempId==depId1)
  }
  
  
  /**
   * Check the getIdOfType
   */
  it must "Return the id by the passed type" in {
    val supervId: Identifier = new Identifier("supervId",IdentifierType.SUPERVISOR,None)
    val dasuId: Identifier = new Identifier("dasuId",IdentifierType.DASU,Option(supervId))
    val asceId: Identifier = new Identifier("asceId",IdentifierType.ASCE,Option(dasuId))
    val iasioId: Identifier = new Identifier("iasioId",IdentifierType.IASIO,Option(asceId))
    
    val i1 = iasioId.getIdOfType(IdentifierType.IASIO)
    assert (i1.isDefined)
    assert(i1.get=="iasioId")
    
    assert(iasioId.getIdOfType(IdentifierType.CONVERTER).isEmpty)
    
    val i2 = iasioId.getIdOfType(IdentifierType.ASCE)
    assert(i2.isDefined)
    assert(i2.get=="asceId")
    
    val i3 = supervId.getIdOfType(IdentifierType.SUPERVISOR)
    assert(i3.isDefined)
    assert(i3.get=="supervId")
    
    assert(supervId.getIdOfType(IdentifierType.PLUGIN).isEmpty)
    
  }
  
  
  behavior of "The object factory (apply)"
  
  /**
   * Check the factory method with a list of tuples (IDs,types)
   */
  it must "allow to build a chain Identifiers" in {
    val id1: Identifier = new Identifier("monSysyId",IdentifierType.MONITORED_SOFTWARE_SYSTEM,None)
    val id2: Identifier = new Identifier("pluginId",IdentifierType.PLUGIN,Option(id1))
    val id3: Identifier = new Identifier("converterId",IdentifierType.CONVERTER,Some(id2))
    val id4: Identifier = new Identifier("iasioId",IdentifierType.IASIO,Option(id3))
    
    val fullRunId = id4.fullRunningID
    
    val theIdent = Identifier(fullRunId)
    assert(fullRunId==theIdent.fullRunningID)
    assert(fullRunId==Identifier.unapply(theIdent))
  }
}