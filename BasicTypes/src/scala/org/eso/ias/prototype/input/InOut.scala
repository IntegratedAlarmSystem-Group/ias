package org.eso.ias.prototype.input

import org.eso.ias.prototype.utils.ISO8601Helper
import org.eso.ias.prototype.input.java.OperationalMode
import org.eso.ias.prototype.input.java.IASTypes._
import org.eso.ias.prototype.input.java.IASTypes
import org.eso.ias.prototype.input.java.IasValidity
import org.eso.ias.prototype.input.java.IasValidity._
import org.eso.ias.prototype.input.java.AlarmSample
import org.eso.ias.prototype.input.java.IASValue
import org.eso.ias.prototype.input.java.IdentifierType

/**
 * A  <code>InOut</code> holds the value of an input or output 
 * of the IAS.
 * Objects of this type constitutes both the input of ASCEs and the output 
 * they produce. They are supposed to live into a ASCE only: their representation
 * in the BSDB is the IASValue[_].
 * 
 * The type of a InOut can be a double, an integer, an
 * array of integers and many other customized types.
 * 
 * The actual value is an Option because there is no
 * value associated before it comes for example from the HW. 
 * Nevertheless the <code>InOut</code> exists
 * 
 * The refresh rate is used to assess the validity for the inputs 
 * coming from external monitored systems or generated by IAS ASCEs.
 * The DASU uses the refreshRate to send the IASIO in output back to
 * the BSDB.
 * The refrshRate of IASIOs generated by ASCEs running inside a DASU that are not
 * the output of DASUs are ignored. 
 * 
 * <code>InOut</code> is immutable.
 * 
 * @param actualValue: the actual value of this InOut (can be undefined) 
 * @param timestamp: the time when this value has been set
 * @param id: The unique ID of the monitor point
 * @param refreshRate: The expected refresh rate (msec) of this monitor point
 *                     (to be used to assess its validity)
 * @param mode: The operational mode
 * @param minDependantValidity: The min validity of the monitor points used by the TFs
 *                             to calculate this IASIOS, if any and None otherwise
 * @param iasType: is the IAS type of this InOut
 * 
 * @see IASType
 * 
 * @author acaproni
 */
case class InOut[A](
    value: Option[_ >: A],
    timestamp: Long,
    id: Identifier,
    refreshRate: Int,    
    mode: OperationalMode,
    minDependantValidity: Option[Validity],
    iasType: IASTypes) {
  require(Option[Identifier](id).isDefined,"The identifier must be defined")
  require(refreshRate>=InOut.MinRefreshRate,"Invalid refresh rate (too low): "+refreshRate)
  require(Option[IASTypes](iasType).isDefined,"The type must be defined")
  
  value.foreach(v => require(InOut.checkType(v,iasType),"Type mismatch: ["+v+"] is not "+iasType))
  
  override def toString(): String = {
    val ret = new StringBuilder("Monitor point [")
    ret.append(id.toString())
    ret.append("] of type ")
    ret.append(iasType)
    ret.append(", mode=")
    ret.append(mode.toString())
    minDependantValidity.foreach(v => {
      ret.append(", inherited validity=")
      ret.append(v.toString())
    })
    ret.append(", ")
    if (value.isEmpty) {
      ret.append("No value")
    } else {
       ret.append("Value: "+value.get.toString())
    }
    ret.toString()
  }
  
  /**
   * Update the mode of the monitor point
   * 
   * @param newMode: The new mode of the monitor point
   */
  def updateMode(newMode: OperationalMode): InOut[A] = {
    this.copy(mode=newMode,timestamp=System.currentTimeMillis())
  }
  
  /**
   * Update the value of a monitor point that has no dependant monitor points
   * i.e. that is not calculated by a TF.
   * 
   * @param newValue: The new value of the monitor point
   * @return A new InOut with updated value and validity
   */
  def updateValue[B >: A](newValue: Option[B]): InOut[A] = {
    InOut(newValue,System.currentTimeMillis(),id,refreshRate,mode,minDependantValidity,iasType)
  }
  
  /**
   * Update the value and min dependant validity of the monitor point
   * 
   * @param newValue: The new value of the monitor point
   * @param minDepValidity: the validity inherited by  the IASIOs used by TF
   * 												to calulate this IASIOs or None if not calculated by a TF
   * @return A new InOut with updated value and validity
   */
  def updateValue[B >: A](newValue: Option[B], minDepValidity: Option[Validity]): InOut[A] = {
    InOut(newValue,System.currentTimeMillis(),id,refreshRate,mode,minDepValidity,iasType)
  }
  
  /**
   * Update the dependant validity i.e. the min validity
   * of the inputs used by the TF to calculate this IASIOs;
   * it is None if the monitor point is not generated by a TF.
   * 
   * @param validties: The validity of the monitor points used by the ASCE
   *                   to calculate this IASIO
   */
  def updateMinDependantValidity(validities: Set[Validity]): InOut[A] = {
    require(Option(validities).isDefined,"Invalid set of validities")
    
    val minValidity=Validity.minValidity(validities.map(_.iasValidity))
    this.copy(minDependantValidity=minValidity)
  }
  
  /**
   * Get the actual validity.
   * 
   * The validity depends on 
   * - the validity of the passed inputs
   * - the last update time vs the actual time and the refresh rate 
   */
  def getValidity(): Validity = {
    val timeValidity=assessTimeValidity()
    (minDependantValidity, timeValidity) match {
      case (None, v) => v
      case (Some(mdv), tv) => if (mdv<=tv) mdv else tv 
    }
  }
  
  /**
   * Establish and return the validity depending on the
   * expected refresh rate and the latest update
   * 
   * @param iasios the IASIOs, if any, 
   * @return the minimum validity
   */
  private def assessTimeValidity(): Validity = {
    val updatedInTime=System.currentTimeMillis()-timestamp<=refreshRate
    if (updatedInTime) {
      Validity(IasValidity.RELIABLE)
    } else {
      Validity(IasValidity.UNRELIABLE)
    }
  }
  
  /**
   * Update the value of this IASIO with the IASValue received from the
   * BSDB
   */
  def update[B >: IASValue[A]](iasValue: B): InOut[A] = {
    val v = iasValue.asInstanceOf[IASValue[A]]
    require(Option(iasValue).isDefined,"Cannot update from a undefined IASIO")
    require(v.id==this.id.id,"Identifier mismatch: received "+v.id+", expected "+this.id.id)
    assert(v.valueType==this.iasType)
    
    updateValue(Option(v.value)).updateMode(v.mode)
  }
}

/** 
 *  InOut companion object
 */
object InOut {
  
  /**
   * The min possible value for the refresh rate
   * If it is too short the value will be invalid most of the time; if too 
   * long it is not possible to understand if it has been properly refreshed or
   * the source is stuck/dead.
   */
  val MinRefreshRate = 50;

  /**
   * Check if the passed value is of the proper type
   * 
   * @param value: The value to check they type against the iasType
   * @param iasType: The IAS type
   */
  def checkType[T](value: T, iasType: IASTypes): Boolean = {
    if (value==None) true
    else iasType match {
      case IASTypes.LONG => value.isInstanceOf[Long]
      case IASTypes.INT => value.isInstanceOf[Int]
      case IASTypes.SHORT => value.isInstanceOf[Short]
      case IASTypes.BYTE => value.isInstanceOf[Byte]
      case IASTypes.DOUBLE => value.isInstanceOf[Double]
      case IASTypes.FLOAT => value.isInstanceOf[Float]
      case IASTypes.BOOLEAN =>value.isInstanceOf[Boolean]
      case IASTypes.CHAR => value.isInstanceOf[Char]
      case IASTypes.STRING => value.isInstanceOf[String]
      case IASTypes.ALARM =>value.isInstanceOf[AlarmSample]
      case _ => false
    }
  }
  
  /**
   * Build a InOut with no initial value neither a mode.
   * 
   * Such a IASIO is useful when it is expected but has not yet been sent
   * by the BSDB or a ASCE: we know that it exists but we do not know its 
   * initial values.
   * 
   * @param id the identifier
   * @param refreshRate the refresh rate of this IASIO
   * @param iasType the type of the value of the IASIO
   * @return a InOut initially empty
   */
  def apply[T](id: Identifier,
    refreshRate: Int,
    iasType: IASTypes): InOut[T] = {
    InOut[T](None,System.currentTimeMillis(),id,refreshRate,OperationalMode.UNKNOWN,None,iasType)
  }
  
  /**
   * Build a IASIO from a IASVAlue received from the BDSB.
   * 
   * @param iasValue the value received from the BSDB
   * @param refreshRate the refresh rate of this IASIO
   * @param parentIdentifier the parent identifier
   * @return the IASIO generated from the passed IASValue
   */
  def apply[T](iasValue: IASValue[T], refreshRate: Int) = {
    val id = Identifier(iasValue.fullRunningId)
    val value = Option[T](iasValue.value)
    val tStamp = iasValue.timestamp
    val mode = iasValue.mode
    val iasType = iasValue.valueType
    new InOut[T](value, tStamp,id,refreshRate ,mode, None,iasType)
  }
}