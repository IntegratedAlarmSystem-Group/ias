package org.eso.ias.types

/**
 * A  <code>InOut</code> holds the value of an input or output 
 * of the IAS.
 * Objects of this type constitutes both the input of ASCEs and the output 
 * they produce. They are supposed to live into a ASCE only: their representation
 * in the BSDB is the IASValue[_].
 * 
 * The type of a InOut can be a double, an integer, an
 * array of integers and many other customized types.
 * 
 * The actual value is an Option because there is no
 * value associated before it comes for example from the HW. 
 * Nevertheless the <code>InOut</code> exists.
 * 
 * The refresh rate is used to assess the validity for the inputs 
 * coming from external monitored systems or generated by IAS ASCEs.
 * The DASU uses the refreshRate to send the IASIO in output back to
 * the BSDB.
 * The refrshRate of IASIOs generated by ASCEs running inside a DASU that are not
 * the output of DASUs are ignored.
 * 
 * If the InOut is the input of a ASCE, it has the validity received from the IASValue
 * in the fromIasValueValidity. Otherwise the validity depends on the validity of the
 * IASValues in input to the ASCE.
 * @see  getValidity(dependantIasios: Option[Set[InOut[_]]])
 * This invariant, is also used for recognizing if the InoOut is an output
 * of the ACSE
 * @see isOutput()
 * 
 * During is entire life, a IASIO is either one of the inputs or the output 
 * of the ACSE so the fromIasValueValidity is either defined or empty:
 * - If it is empty it remains empty forwver; 
 * - if it is defined it will remain defined forever
 * This invariant is checked is several parts of the code. 
 * 
 * 
 * <code>InOut</code> is immutable.
 * 
 * @param actualValue: the actual value of this InOut (can be undefined) 
 * @param timestamp: the time when this value has been set
 * @param id: The unique ID of the monitor point
 * @param refreshRate: The expected refresh rate (msec) of this monitor point
 *                     (to be used to assess its validity)
 * @param mode: The operational mode
 * @param fromIasValueValidity: The validity received from the BSDB (i.e. from a IASValue)
 *                           It is None if and only if the value is generated by ASCE
 * @param iasType: is the IAS type of this InOut
 * 
 * @see IASType
 * 
 * @author acaproni
 */
case class InOut[A](
    value: Option[_ >: A],
    timestamp: Long,
    id: Identifier,
    refreshRate: Int,    
    mode: OperationalMode,
    fromIasValueValidity: Option[Validity],
    iasType: IASTypes) {
  require(Option[Identifier](id).isDefined,"The identifier must be defined")
  require(refreshRate>=InOut.MinRefreshRate,"Invalid refresh rate (too low): "+refreshRate)
  require(Option[IASTypes](iasType).isDefined,"The type must be defined")
  
  value.foreach(v => require(InOut.checkType(v,iasType),"Type mismatch: ["+v+"] is not "+iasType))
  
  override def toString(): String = {
    val ret = new StringBuilder("Monitor point [")
    ret.append(id.toString())
    ret.append("] of type ")
    ret.append(iasType)
    ret.append(", mode=")
    ret.append(mode.toString())
    fromIasValueValidity.foreach(v => {
      ret.append(", inherited validity=")
      ret.append(v.toString())
    })
    ret.append(", ")
    if (value.isEmpty) {
      ret.append("No value")
    } else {
       ret.append("Value: "+value.get.toString())
    }
    ret.toString()
  }
  
  /**
   * Update the mode of the monitor point
   * 
   * @param newMode: The new mode of the monitor point
   */
  def updateMode(newMode: OperationalMode): InOut[A] = {
    this.copy(mode=newMode,timestamp=System.currentTimeMillis())
  }
  
  /**
   * Update the value of a monitor point that has no dependant monitor points
   * i.e. that is not calculated by a TF.
   * 
   * @param newValue: The new value of the monitor point
   * @return A new InOut with updated value and validity
   */
  def updateValue[B >: A](newValue: Option[B]): InOut[A] = {
    InOut(newValue,System.currentTimeMillis(),id,refreshRate,mode,fromIasValueValidity,iasType)
  }
  
  /**
   * Update the value and min dependant validity of the monitor point
   * 
   * @param newValue: The new value of the monitor point
   * @param minDepValidity: the validity inherited by  the IASIOs used by TF
   * 												to calulate this IASIOs or None if not calculated by a TF
   * @return A new InOut with updated value and validity
   */
  def updateValue[B >: A](newValue: Option[B], minDepValidity: Option[Validity]): InOut[A] = {
    InOut(newValue,System.currentTimeMillis(),id,refreshRate,mode,minDepValidity,iasType)
  }
  
  /**
   * Update the inherited validity, i.e. the validity received from a IASValue
   */
  def updatedInheritedValidity(validity: Option[Validity]):InOut[A] = {
    assert(validity.isDefined && fromIasValueValidity.isDefined)
    this.copy(timestamp=System.currentTimeMillis(), fromIasValueValidity=validity)
  }
  
  /**
   * @return true if this IASIO is the generated by the ASCE,
   *         lase otherwise (i.e. the input of the ASCE)
   */
  def isOutput() = fromIasValueValidity.isEmpty

  /**
   * Get the actual validity.
   * 
   * The validity depends on 
   * - fromIasValueValidity, the validity inherited while converting 
   *   from IASValue (if Any)
   *   (this option applies to the inputs of a ASCE)
   * - the validity of the dependants inputs (if any)
   *   (this applies to the output of the ASCE whose validity depends
   *   on the validity of the inputs)
   * - the last update time vs the actual time and the refresh rate
   * 
   * There is a invariant between fromIasValueValidity and dependantIasios:
   * only one of the 2 must be a None while the other option is always a Some.
   * In fact a IASIO in a ASCE can only be a input of the
   * output: if it is an input then it is a IASValue that once converted to a IASIO
   * must have the fromIasValueValidity defined but has no dependants;
   * if it is the output of a ASCE then it is not generated by a IASValue and 
   * its fromIasValueValidity is always None but it has dependatIasios, the
   * one used to calculate the TF.
   * 
   * @param dependantIasios The IASIOs whose this IASIOs depends on 
   *        for establishing the validity, if any.
   * @return the actual validity
   */
  def getValidity(dependantIasios: Option[Set[InOut[_]]]): Validity = {
    dependantIasios match {
      case None => getValidity()
      case Some(deps) => getValidity(deps)
    }
  }
  
  /**
   * Get the validity of a IASIO that has no dependant monitor points
   * 
   * This is the case of the inputs of a ASCE generated from IASValues
   * received from the BSDB
   * 
   * @return the actual validity
   */
  def getValidity(): Validity = {
    assert(fromIasValueValidity.isDefined,"A IASIO either has deps or has a valdiity inherited from a IASValue")
    
    // Check the last update time against the actual time 
    val timeValidity = assessTimeValidity()
    
    Validity.minValidity(Set(timeValidity.iasValidity,fromIasValueValidity.get.iasValidity))
  }
  
  /**
   * Get the validity of a IASIO that has dependant monitor points
   * 
   * This is the case of the output produced by a ASCE
   * 
   * @param dependantIasios The IASIOs whose this IASIOs depends on 
   *                        for establishing the validity
   * @return the actual validity
   */
  def getValidity(dependantIasios: Set[InOut[_]]): Validity = {
    require(Option(dependantIasios).isDefined,"Invalid set of dependsnts")
    require(!dependantIasios.isEmpty,"Invalid set of empty dependants: use getValidity() instead")
    assert(fromIasValueValidity.isEmpty,"A IASIO with dependants can't have a validity inherited from a IASValue")
    
    // Check the last update time against the actual time 
    val timeValidity = assessTimeValidity().iasValidity
    
    // The validities of dependants
    val dependantValiditySet = dependantIasios.map(i => i.getValidity().iasValidity)
    
    Validity.minValidity(dependantValiditySet+timeValidity)
  }
  
  /**
   * Establish and return the validity depending on the
   * expected refresh rate and the latest update
   * 
   * @param iasios the IASIOs, if any, 
   * @return the minimum validity
   */
  def assessTimeValidity(): Validity = {
    val updatedInTime=System.currentTimeMillis()-timestamp<=refreshRate
    if (updatedInTime) {
      Validity(IasValidity.RELIABLE)
    } else {
      Validity(IasValidity.UNRELIABLE)
    }
  }
  
  /**
   * Update the value of this IASIO with the IASValue received from the
   * BSDB
   */
  def update[B >: IASValue[A]](iasValue: B): InOut[A] = {
    val v = iasValue.asInstanceOf[IASValue[A]]
    require(Option(iasValue).isDefined,"Cannot update from a undefined IASIO")
    require(v.id==this.id.id,"Identifier mismatch: received "+v.id+", expected "+this.id.id)
    assert(v.valueType==this.iasType)
    
    
    val ret = updateValue(Option(v.value)).updateMode(v.mode)
    
    // If it is an input then we have to update also the inherited validity
    if (fromIasValueValidity.isDefined) {
      ret.updatedInheritedValidity(Option(Validity(v.iasValidity)))
    } else {
      ret
    }
  }
}

/** 
 *  InOut companion object
 */
object InOut {
  
  /**
   * The min possible value for the refresh rate
   * If it is too short the value will be invalid most of the time; if too 
   * long it is not possible to understand if it has been properly refreshed or
   * the source is stuck/dead.
   */
  val MinRefreshRate = 50;

  /**
   * Check if the passed value is of the proper type
   * 
   * @param value: The value to check they type against the iasType
   * @param iasType: The IAS type
   */
  def checkType[T](value: T, iasType: IASTypes): Boolean = {
    if (value==None) true
    else iasType match {
      case IASTypes.LONG => value.isInstanceOf[Long]
      case IASTypes.INT => value.isInstanceOf[Int]
      case IASTypes.SHORT => value.isInstanceOf[Short]
      case IASTypes.BYTE => value.isInstanceOf[Byte]
      case IASTypes.DOUBLE => value.isInstanceOf[Double]
      case IASTypes.FLOAT => value.isInstanceOf[Float]
      case IASTypes.BOOLEAN =>value.isInstanceOf[Boolean]
      case IASTypes.CHAR => value.isInstanceOf[Char]
      case IASTypes.STRING => value.isInstanceOf[String]
      case IASTypes.ALARM =>value.isInstanceOf[AlarmSample]
      case _ => false
    }
  }
  
  /**
   * Build a InOut with no initial value neither a mode.
   * 
   * Such a IASIO is useful when it is expected but has not yet been sent
   * by the BSDB or a ASCE: we know that it exists but we do not know its 
   * initial values.
   * 
   * @param id the identifier
   * @param refreshRate the refresh rate of this IASIO
   * @param iasType the type of the value of the IASIO
   * @return a InOut initially empty
   */
  def apply[T](id: Identifier,
    refreshRate: Int,
    iasType: IASTypes): InOut[T] = {
    InOut[T](None,System.currentTimeMillis(),id,refreshRate,OperationalMode.UNKNOWN,None,iasType)
  }
  
  /**
   * Build a IASIO from a IASVAlue received from the BDSB.
   * 
   * @param iasValue the value received from the BSDB
   * @param refreshRate the refresh rate of this IASIO
   * @param parentIdentifier the parent identifier
   * @return the IASIO generated from the passed IASValue
   */
  def apply[T](iasValue: IASValue[T], refreshRate: Int) = {
    val id = Identifier(iasValue.fullRunningId)
    val value = Option[T](iasValue.value)
    val tStamp = iasValue.timestamp
    val mode = iasValue.mode
    val iasType = iasValue.valueType
    val inheritedValidity = Some(Validity(iasValue.iasValidity))
    new InOut[T](value, tStamp,id,refreshRate ,mode, inheritedValidity,iasType)
  }
}