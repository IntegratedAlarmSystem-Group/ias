package org.eso.ias.types

/**
 * A  <code>InOut</code> holds the value of an input or output 
 * of the IAS.
 * Objects of this type constitutes both the input of ASCEs and the output 
 * they produce. They are supposed to live into a ASCE only: their representation
 * in the BSDB is the IASValue[_].
 * 
 * The type of a InOut can be a double, an integer, an
 * array of integers and many other customized types.
 * 
 * The actual value is an Option because there is no
 * value associated before it comes for example from the HW. 
 * Nevertheless the <code>InOut</code> exists.
 * 
 * The refresh rate is used to assess the validity for the inputs 
 * coming from external monitored systems or generated by IAS ASCEs.
 * The DASU uses the refreshRate to send the IASIO in output back to
 * the BSDB.
 * The refrshRate of IASIOs generated by ASCEs running inside a DASU that are not
 * the output of DASUs are ignored.
 * 
 * If the InOut is the input of a ASCE, it has the validity received from the IASValue
 * in the fromIasValueValidity. Otherwise the validity depends on the validity of the
 * IASValues in input to the ASCE.
 * @see  getValidity(dependantIasios: Option[Set[InOut[_]]])
 * This invariant, is also used for recognizing if the InoOut is an output
 * of the ACSE
 * @see isOutput()
 * 
 * During is entire life, a IASIO is either one of the inputs or the output 
 * of the ACSE so the fromIasValueValidity is either defined or empty:
 * - If it is empty it remains empty forwver; 
 * - if it is defined it will remain defined forever
 * This invariant is checked is several parts of the code. 
 * 
 * 
 * <code>InOut</code> is immutable.
 * 
 * @param value: the value of this InOut (can be empty) 
 * @param id: The unique ID of the monitor point
 * @param mode: The operational mode
 * @param fromIasValueValidity: The validity received from the BSDB (i.e. from a IASValue)
 *                           It is None if and only if the value is generated by ASCE
 * @param iasType: is the IAS type of this InOut
 * @param pluginProductionTStamp The point in time when the plugin produced this value
 * @param sentToConverterTStamp The point in time when the plugin sent the value to the converter
 * @param receivedFromPluginTStamp The point in time when the converter received the value from the plugin
 * @param convertedProductionTStamp The point in time when the converter generated
 *                                  the value from the data structure rceived by the plugin
 * @param sentToBsdbTStamp The point in time when the value has been sent to the BSDB
 * @param readFromBsdbTStamp The point in time when the value has been read from the BSDB
 * @param dasuProductionTStamp The point in time when the value has been generated by the DASU
 * 
 * @see IASType
 * 
 * @author acaproni
 */
case class InOut[A](
    value: Option[_ >: A],
    id: Identifier,
    mode: OperationalMode,
    fromIasValueValidity: Option[Validity],
    iasType: IASTypes,
    pluginProductionTStamp: Option[Long],
	  sentToConverterTStamp: Option[Long],
	  receivedFromPluginTStamp: Option[Long],
	  convertedProductionTStamp: Option[Long],
	  sentToBsdbTStamp: Option[Long],
	  readFromBsdbTStamp: Option[Long],
	  dasuProductionTStamp: Option[Long]) {
  require(Option[Identifier](id).isDefined,"The identifier must be defined")
  require(Option[IASTypes](iasType).isDefined,"The type must be defined")
  
  value.foreach(v => require(InOut.checkType(v,iasType),"Type mismatch: ["+v+"] is not "+iasType))
  
  override def toString(): String = {
    val ret = new StringBuilder("Monitor point [")
    ret.append(id.toString())
    ret.append("] of type ")
    ret.append(iasType)
    ret.append(", mode=")
    ret.append(mode.toString())
    fromIasValueValidity.foreach(v => {
      ret.append(", inherited validity=")
      ret.append(v.toString())
    })
    ret.append(", ")
    if (value.isEmpty) {
      ret.append("No value")
    } else {
       ret.append("Value: "+value.get.toString())
    }
    ret.toString()
  }
  
  /**
   * Update the mode of the monitor point
   * 
   * @param newMode: The new mode of the monitor point
   */
  def updateMode(newMode: OperationalMode): InOut[A] = {
    this.copy(mode=newMode, dasuProductionTStamp=Some(System.currentTimeMillis()))
  }
  
  /**
   * Update the value of a monitor point that has no dependant monitor points
   * i.e. that is not calculated by a TF.
   * 
   * @param newValue: The new value of the monitor point
   * @return A new InOut with updated value and validity
   */
  def updateValue[B >: A](newValue: Option[B]): InOut[A] = {
    this.copy(value=newValue, dasuProductionTStamp=Some(System.currentTimeMillis()))
  }
  
  /**
   * Update the value and min dependant validity of the monitor point
   * 
   * @param newValue: The new value of the monitor point
   * @param minDepValidity: the validity inherited by  the IASIOs used by TF
   * 												to calulate this IASIOs or None if not calculated by a TF
   * @return A new InOut with updated value and validity
   */
  def updateValue[B >: A](newValue: Option[B], minDepValidity: Option[Validity]): InOut[A] = {
    this.copy(value=newValue,fromIasValueValidity=minDepValidity, dasuProductionTStamp=Some(System.currentTimeMillis()))
  }
  
  /**
   * Update the inherited validity, i.e. the validity received from a IASValue
   */
  def updatedInheritedValidity(validity: Option[Validity]):InOut[A] = {
    assert(validity.isDefined && fromIasValueValidity.isDefined)
    this.copy(fromIasValueValidity=validity, dasuProductionTStamp=Some(System.currentTimeMillis()))
  }
  
  /**
   * @return true if this IASIO is the generated by the ASCE,
   *         lase otherwise (i.e. the input of the ASCE)
   */
  def isOutput() = fromIasValueValidity.isEmpty

  /**
   * Get the actual validity.
   * 
   * The validity depends on 
   * - fromIasValueValidity, the validity inherited while converting 
   *   from IASValue (if Any)
   *   (this option applies to the inputs of a ASCE)
   * - the validity of the dependants inputs (if any)
   *   (this applies to the output of the ASCE whose validity depends
   *   on the validity of the inputs)
   * - the last update time vs the actual time and the refresh rate
   * 
   * There is a invariant between fromIasValueValidity and dependantIasios:
   * only one of the 2 must be a None while the other option is always a Some.
   * In fact a IASIO in a ASCE can only be a input of the
   * output: if it is an input then it is a IASValue that once converted to a IASIO
   * must have the fromIasValueValidity defined but has no dependants;
   * if it is the output of a ASCE then it is not generated by a IASValue and 
   * its fromIasValueValidity is always None but it has dependatIasios, the
   * one used to calculate the TF.
   * 
   * @param dependantIasios The IASIOs whose this IASIOs depends on 
   *        for establishing the validity, if any.
   * @return the actual validity
   */
  def getValidity(dependantIasios: Option[Set[InOut[_]]]): Validity = {
    dependantIasios match {
      case None => getValidity()
      case Some(deps) => getValidity(deps)
    }
  }
  
  /**
   * Get the validity of a IASIO that has no dependant monitor points
   * 
   * This is the case of the inputs of a ASCE generated from IASValues
   * received from the BSDB
   * 
   * @return the actual validity
   */
  def getValidity(): Validity = {
    assert(fromIasValueValidity.isDefined,"A IASIO either has deps or has a valdiity inherited from a IASValue")
    
    // Check the last update time against the actual time 
    val timeValidity = assessTimeValidity()
    
    Validity.minValidity(Set(timeValidity.iasValidity,fromIasValueValidity.get.iasValidity))
  }
  
  /**
   * Get the validity of a IASIO that has dependant monitor points
   * 
   * This is the case of the output produced by a ASCE
   * 
   * @param dependantIasios The IASIOs whose this IASIOs depends on 
   *                        for establishing the validity
   * @return the actual validity
   */
  def getValidity(dependantIasios: Set[InOut[_]]): Validity = {
    require(Option(dependantIasios).isDefined,"Invalid set of dependsnts")
    require(!dependantIasios.isEmpty,"Invalid set of empty dependants: use getValidity() instead")
    assert(fromIasValueValidity.isEmpty,"A IASIO with dependants can't have a validity inherited from a IASValue")
    
    // Check the last update time against the actual time 
    val timeValidity = assessTimeValidity().iasValidity
    
    // The validities of dependents
    val dependantValiditySet = dependantIasios.map(i => i.getValidity().iasValidity)
    
    Validity.minValidity(dependantValiditySet+timeValidity)
  }
  
  /**
   * Establish and return the validity depending on the
   * expected refresh rate and the latest update
   * 
   * TODO: FIX!
   * 
   * @param iasios the IASIOs, if any, 
   * @return the minimum validity
   */
  def assessTimeValidity(): Validity = {
    Validity(IasValidity.UNRELIABLE)
  }
  
  /**
   * Update the value of this IASIO with the IASValue received from the
   * BSDB
   */
  def update[B >: IASValue[A]](iasValue: B): InOut[A] = {
    val v = iasValue.asInstanceOf[IASValue[A]]
    require(Option(iasValue).isDefined,"Cannot update from a undefined IASIO")
    require(v.id==this.id.id,"Identifier mismatch: received "+v.id+", expected "+this.id.id)
    assert(v.valueType==this.iasType)
    
    
    val ret = updateValue(Option(v.value)).updateMode(v.mode)
    
    // If it is an input then we have to update also the inherited validity
    if (fromIasValueValidity.isDefined) {
      ret.updatedInheritedValidity(Option(Validity(v.iasValidity)))
    } else {
      ret
    }
  }
}

/** 
 *  InOut companion object
 */
object InOut {
  
  /**
   * Check if the passed value is of the proper type
   * 
   * @param value: The value to check they type against the iasType
   * @param iasType: The IAS type
   */
  def checkType[T](value: T, iasType: IASTypes): Boolean = {
    if (value==None) true
    else iasType match {
      case IASTypes.LONG => value.isInstanceOf[Long]
      case IASTypes.INT => value.isInstanceOf[Int]
      case IASTypes.SHORT => value.isInstanceOf[Short]
      case IASTypes.BYTE => value.isInstanceOf[Byte]
      case IASTypes.DOUBLE => value.isInstanceOf[Double]
      case IASTypes.FLOAT => value.isInstanceOf[Float]
      case IASTypes.BOOLEAN =>value.isInstanceOf[Boolean]
      case IASTypes.CHAR => value.isInstanceOf[Char]
      case IASTypes.STRING => value.isInstanceOf[String]
      case IASTypes.ALARM =>value.isInstanceOf[AlarmSample]
      case _ => false
    }
  }
  
  /**
   * Build a InOut with no initial value neither a mode.
   * 
   * Such a IASIO is useful when it is expected but has not yet been sent
   * by the BSDB or a ASCE: we know that it exists but we do not know its 
   * initial values.
   * 
   * @param id the identifier
   * @param iasType the type of the value of the IASIO
   * @return a InOut initially empty
   */
  def apply[T](id: Identifier, iasType: IASTypes): InOut[T] = {
    InOut[T](None,id,OperationalMode.UNKNOWN,None,iasType,None,None,None,None,None,None,None)
  }
  
  /**
   * Build a InOut with no initial value neither a mode but with
   * the val;idity inherited from the IASValue
   * 
   * This is an input to a ACSE.
   * 
   * @param id the identifier
   * @param iasType the type of the value of the IASIO
   * @return a InOut initially empty
   */
  def apply[T](id: Identifier, iasType: IASTypes, iasValidity: IasValidity): InOut[T] = {
    InOut[T](None,id,OperationalMode.UNKNOWN,Some(Validity(iasValidity)),iasType,None,None,None,None,None,None,None)
  }
  
  /**
   * Build a IASIO from a IASVAlue received from the BDSB.
   * 
   * @param iasValue the value received from the BSDB
   * @return the IASIO generated from the passed IASValue
   */
  def fromIasValue[T](iasValue: IASValue[T]) = {
    val mode = iasValue.mode
    val iasType = iasValue.valueType
    
    new InOut[T](
        Option[T](iasValue.value),
        Identifier(iasValue.fullRunningId),
        iasValue.mode,
        Some(Validity(iasValue.iasValidity)),
        iasValue.valueType,
        if (iasValue.pluginProductionTStamp.isPresent()) Some(iasValue.pluginProductionTStamp.get()) else None,
	      if (iasValue.sentToConverterTStamp.isPresent()) Some(iasValue.sentToConverterTStamp.get()) else None,
	      if (iasValue.receivedFromPluginTStamp.isPresent()) Some(iasValue.receivedFromPluginTStamp.get()) else None,
	      if (iasValue.convertedProductionTStamp.isPresent()) Some(iasValue.convertedProductionTStamp.get()) else None,
	      if (iasValue.sentToBsdbTStamp.isPresent()) Some(iasValue.sentToBsdbTStamp.get()) else None,
	      if (iasValue.readFromBsdbTStamp.isPresent()) Some(iasValue.readFromBsdbTStamp.get()) else None,
	      if (iasValue.dasuProductionTStamp.isPresent()) Some(iasValue.dasuProductionTStamp.get()) else None)
    
  }
}